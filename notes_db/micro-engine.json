{
  "sections": [
    {
      "title": "Main Project micro-engine",
      "chats": [
        {
          "indexTitle": "Repository",
          "question": "Repository",
          "answer": "1. Local Repository \n```bash\n    C:\\atari-monk\\code\\micro-engine)\n```\n2. [GitHub Repository](https://github.com/atari-monk/micro-engine)",
          "dateTime": "2023-11-16T14:25:21.898Z"
        },
        {
          "indexTitle": "File .gitignore",
          "question": "File .gitignore",
          "answer": "Initially, just two elements, excluded from commit, should be fine. \n\n```bash\nbuild\nnode_modules\n```",
          "dateTime": "2023-11-16T15:05:25.536Z"
        },
        {
          "indexTitle": "Formater",
          "question": "File .prettierrc",
          "answer": "Formatting is delegated to prettier with this config:\n\n```json\n{\n  \"singleQuote\": true,\n  \"indent\": 2,\n  \"semi\": false\n}\n```\n",
          "dateTime": "2023-11-16T19:02:05.477Z"
        },
        {
          "indexTitle": "Script",
          "question": "Script",
          "answer": "Folder script contains scripts shared by projects",
          "dateTime": "2023-11-16T15:19:20.594Z"
        },
        {
          "indexTitle": "Script copy-package.js",
          "question": "Script copy-package.js  \nCopy package.json to folder build in project",
          "answer": "```bash\ncopy-package.js\n```\n```javascript\nconst fs = require('fs')\nconst path = require('path')\n\nfunction getPaths(sourceFile, targetDir) {\n  const dirname = __dirname\n  const dirname_resolve = path.resolve(dirname, '.')\n\n  const sourcePath = path.join(dirname_resolve, sourceFile)\n\n  const targetPath = path.join(\n    dirname_resolve,\n    targetDir,\n    path.basename(sourceFile)\n  )\n\n  return {\n    dirname_resolve: dirname_resolve,\n    sourcePath: sourcePath,\n    targetPath: targetPath,\n  }\n}\n\nfunction printPaths(paths) {\n  console.log('dirname_resolve:', paths.dirname_resolve)\n  console.log('sourcePath:', paths.sourcePath)\n  console.log('targetPath:', paths.targetPath)\n}\n\nfunction copyFileToBuild(paths) {\n  if (!fs.existsSync(path.dirname(paths.targetPath))) {\n    fs.mkdirSync(path.dirname(paths.targetPath), { recursive: true })\n  }\n\n  fs.copyFileSync(paths.sourcePath, paths.targetPath)\n\n  console.log(`Copied ${paths.sourcePath} to ${paths.targetPath}`)\n}\n\nmodule.exports = { getPaths, printPaths, copyFileToBuild }\n```",
          "dateTime": "2023-11-16T19:04:31.976Z"
        },
        {
          "indexTitle": "Script CommonFunctions.ps1",
          "question": "Script CommonFunctions.ps1  \nThis is for installing lib to other projects using local .tgz package",
          "answer": "```bash\nCommonFunctions.ps1\n```\n```powershell\n$Global:RepoPath = \"C:\\atari-monk\\Code\\micro-engine\\\"\n\nfunction Build-Lib () {\n  npm i\n  npm run build\n  Set-Location build\n  npm pack  \n}\n\nfunction Copy-And-Install-Pack {\n  param (\n    [string]$packPath,\n    [string]$projDir,\n    [string]$packName\n  )\n  Copy-Item $packPath $projDir \n  Set-Location $projDir\n  npm i (Get-Item $packName).Name\n}\n```",
          "dateTime": "2023-11-16T19:06:17.823Z"
        },
        {
          "indexTitle": "Order Projects",
          "question": "Order Projects in Visual Studio Code",
          "answer": "File->Save Workspace As...\n```json\n{\n  \"folders\": [\n    {\n      \"name\": \"engine_api\",\n      \"path\": \"engine_api\"\n    },\n    {\n      \"name\": \"engine\",\n      \"path\": \"engine\"\n    },\n    {\n      \"name\": \"engine_node_tests\",\n      \"path\": \"engine_node_tests\"\n    },\n    {\n      \"name\": \"engine_jsdom_tests\",\n      \"path\": \"engine_jsdom_tests\"\n    },\n    {\n      \"name\": \"sln\",\n      \"path\": \".\"\n    }\n  ],\n  \"settings\": {\n    \"files.exclude\": {\n      \"**/engine_api/**\": true,\n      \"**/engine/**\": true,\n      \"**/engine_node_tests/**\": true,\n      \"**/engine_jsdom_tests/**\": true\n    }\n  }\n}\n```\nThis shows projects from path under name  \n. selects all i guess, but exclude in settings removes projs so only sln files and folders remain",
          "dateTime": "2023-11-17T15:49:56.843Z"
        }
      ]
    },
    {
      "title": "Project engine_api",
      "chats": [
        {
          "indexTitle": "Assumptions",
          "question": "Assumptions",
          "answer": "1. Typescript library\n2. API that describes my engine\n3. Each folder is name of the component with it's interfaces\n4. This will be used by client and server of game as a technology layer in form of library package, or by libs of game used by client and server\n",
          "dateTime": "2023-11-16T16:30:51.953Z"
        },
        {
          "indexTitle": "File package.json",
          "question": "File package.json",
          "answer": "```json\n{\n  \"name\": \"engine_api\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Description of my engine\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"build\": \"node ./script/copy-package.js && tsc\",\n    \"i-lib\": \"powershell.exe -ExecutionPolicy Bypass -File .\\\\script\\\\i-lib.ps1\"\n  },\n  \"keywords\": [\n    \"typescript\",\n    \"library\",\n    \"engine api\"\n  ],\n  \"author\": \"atari_monk\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"typescript\": \"^5.2.2\"\n  },\n  \"dependencies\": {}\n}\n```",
          "dateTime": "2023-11-16T16:18:49.280Z"
        },
        {
          "indexTitle": "File tsconfig.json",
          "question": "File tsconfig.json",
          "answer": "```json\n{\n  \"compilerOptions\": {\n    \"target\": \"es2016\",\n    \"module\": \"commonjs\",\n    \"outDir\": \"./build\",\n    \"declarationDir\": \"./build\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"skipLibCheck\": true,\n    \"declaration\": true\n  },\n  \"exclude\": [\"node_modules\", \"script\", \"build\"]\n}\n```",
          "dateTime": "2023-11-16T16:16:26.180Z"
        },
        {
          "indexTitle": "Script",
          "question": "script folder",
          "answer": "* Folder with scripts of the project\n* usually used in package.json \"scripts\":\n",
          "dateTime": "2023-11-16T16:23:52.096Z"
        },
        {
          "indexTitle": "Script copy-package.js",
          "question": "Script copy-package.js  \nAssuming lib and proj structure, this copies package.json to build if valid proj folder is set",
          "answer": "```bash\ncopy-package.js\n```\n```javascript\nconst lib = require('./../../script/copy-package')\n\nconst projFolder = 'engine_api'\nconst sourceFile = `../${projFolder}/package.json`\nconst targetDir = `../${projFolder}/build`\nconst debug = false\n\nconst paths = lib.getPaths(sourceFile, targetDir)\nif (debug) lib.printPaths(paths)\nlib.copyFileToBuild(paths)\n```",
          "dateTime": "2023-11-16T19:16:05.142Z"
        },
        {
          "indexTitle": "Script i-lib.ps1",
          "question": "Script i-lib.ps1  \nThis installs lib to repo projects according to list using local package",
          "answer": "```bash\ni-lib.ps1\n```\n```powershell\n. \"C:\\atari-monk\\Code\\micro-engine\\script\\CommonFunctions.ps1\"\n\n$libFolder = \"engine_api\"\n$libName = \"engine_api\"\n$build = \"$libFolder\\build\\\"\n$pack = \"$libName-1.0.0.tgz\"\n$lib = $RepoPath + $build + $pack\n\n$targetProjects = @(\n  \"$RepoPath\\engine\\\",\n  \"$RepoPath\\engine_tests\\\"\n)\n\nBuild-Lib\nforeach ($targetProj in $targetProjects) {\n  Copy-And-Install-Pack -packPath $lib -projDir $targetProj -packName $pack\n}\n```",
          "dateTime": "2023-11-16T19:16:40.273Z"
        }
      ]
    },
    {
      "title": "Project engine",
      "chats": [
        {
          "indexTitle": "Assumptions",
          "question": "Assumptions",
          "answer": "1. Same project template as engine_api\n2. Implementation of my engine\n3. Implementation of engine_api lib\n4. This will be used by client and server of a game or libs that will be used in them\n\n\n",
          "dateTime": "2023-11-16T16:40:06.479Z"
        }
      ]
    },
    {
      "title": "Project engine_node_tests",
      "chats": [
        {
          "indexTitle": "Assumptions",
          "question": "Assumptions",
          "answer": "1. Tests for engine_api and engine libs\n2. Test Environment: 'node'",
          "dateTime": "2023-11-17T13:19:57.748Z"
        },
        {
          "indexTitle": "Initial configuration",
          "question": "Initial configuration",
          "answer": "1. Project template copied from engine_api and ajusted\n2. Install  jest\n```bash\nnpm install --save-dev jest ts-jest @types/jest\n```\n3. Configure jest\n```bash\njest.config.js\n```\n```javascript\nmodule.exports = {\n  preset: 'ts-jest',\n  testEnvironment: 'node',\n  testRegex: '(/__tests__/.*|(\\\\.|/)(test|spec))\\\\.tsx?$',\n};\n```\n4. Add tests\n5. Run test\n```bash\nnpm test\n```",
          "dateTime": "2023-11-16T16:53:55.188Z"
        },
        {
          "indexTitle": "Debug",
          "question": "Debug",
          "answer": "```json\n\"devDependencies\": {\n    \"@types/jest\": \"^29.5.8\",\n    \"jest\": \"^29.7.0\",\n    \"ts-jest\": \"^29.1.1\",\n    \"ts-node\": \"^10.9.1\",\n    \"typescript\": \"^5.2.2\"\n  }\n```\n```bash\n \"debug:test\": \"node --inspect-brk -r ts-node/register ./node_modules/jest/bin/jest.js --runInBand --detectOpenHandles\"\n```\nF12 in chrome, There should be node icon for node dev tools  \nWrite beakpoint in test\n```bash\ndebbuger\n```\n```bash\nnpm run debug:test\n```\nBrakpoints were available in node dev tool",
          "dateTime": "2023-11-16T20:20:40.430Z"
        }
      ]
    },
    {
      "title": "Project engine_jsdom_tests",
      "chats": [
        {
          "indexTitle": "Assumptions",
          "question": "Assumptions",
          "answer": "1. Tests for engine in js dom environment",
          "dateTime": "2023-11-17T18:48:39.197Z"
        },
        {
          "indexTitle": "Initial configuration",
          "question": "Initial configuration",
          "answer": "1. tsconfig.json and package.json copied from engine_node_tests and ajusted\n2. test libs \n```json\n\"devDependencies\": {\n    \"@types/jest\": \"^29.5.8\",\n    \"@types/jsdom\": \"^21.1.5\",\n    \"jest\": \"^29.7.0\",\n    \"jest-canvas-mock\": \"^2.5.2\",\n    \"jest-environment-jsdom\": \"^29.7.0\",\n    \"jsdom\": \"^22.1.0\",\n    \"ts-jest\": \"^29.1.1\"\n  }\n```\n3. jest.config.js\n```javascript\nmodule.exports = {\n  preset: 'ts-jest',\n  testEnvironment: 'jest-environment-jsdom',\n  setupFiles: ['./src/setupTests.ts'],\n  testRegex: '(/__tests__/.*|(\\\\.|/)(test|spec))\\\\.tsx?$',\n}\n```\n4. setupTests.ts\n```typescript\nimport 'jest-canvas-mock'\n```",
          "dateTime": "2023-11-17T18:54:46.249Z"
        }
      ]
    },
    {
      "title": "Vector2",
      "chats": [
        {
          "indexTitle": "Assumptions",
          "question": "Assumptions",
          "answer": "1. Folder math \n2. Simple vector 2d implementation\n3. Squered length to avoid using sqrt for performance (is it still justified?)\n4. default values in ctor\n5. chainable operations\n6. this in type check\n7. static factories of special vectors\n8. immutable version",
          "dateTime": "2023-11-16T20:11:56.911Z"
        },
        {
          "indexTitle": "API",
          "question": "API",
          "answer": "```typescript\nexport interface IVector2 {\n  x: number\n  y: number\n\n  add(other: IVector2): IVector2\n  subtract(other: IVector2): IVector2\n  multiply(scalar: number): IVector2\n  dot(other: IVector2): number\n  length(): number\n  squaredLength(): number\n  normalize(): IVector2\n}\n```",
          "dateTime": "2023-11-16T17:17:34.718Z"
        },
        {
          "indexTitle": "Vector2",
          "question": "Vector2",
          "answer": "```typescript\nimport { IVector2 } from 'engine_api'\n\ntype Operation = 'add' | 'subtract' | 'multiply' | 'divide'\n\nconst operationMap: Record<Operation, (a: number, b: number) => number> = {\n  add: (a, b) => a + b,\n  subtract: (a, b) => a - b,\n  multiply: (a, b) => a * b,\n  divide: (a, b) => (b !== 0 ? a / b : a),\n}\n\nexport default class Vector2 implements IVector2 {\n  public x: number\n  public y: number\n\n  constructor(x: number = 0, y: number = 0) {\n    this.x = x\n    this.y = y\n  }\n\n  private operate(\n    { x = 0, y = 0 }: IVector2 | { x: number; y: number } = { x: 0, y: 0 },\n    operation: Operation = 'add'\n  ): this {\n    this.x = operationMap[operation](this.x, x)\n    this.y = operationMap[operation](this.y, y)\n\n    return this\n  }\n\n  add(other: IVector2): this {\n    return this.operate(other, 'add')\n  }\n\n  subtract(other: IVector2): this {\n    return this.operate(other, 'subtract')\n  }\n\n  multiply(scalar: number): this {\n    return this.operate({ x: scalar, y: scalar }, 'multiply')\n  }\n\n  dot(other: IVector2): number {\n    return this.x * other.x + this.y * other.y\n  }\n\n  length(): number {\n    return Math.hypot(this.x, this.y)\n  }\n\n  squaredLength(): number {\n    return this.x * this.x + this.y * this.y\n  }\n\n  normalize(): this {\n    const mag = this.length()\n    if (mag !== 0) {\n      this.operate({ x: mag, y: mag }, 'divide')\n    }\n    return this\n  }\n\n  static zero(): Vector2 {\n    return new Vector2()\n  }\n\n  static unitX(): Vector2 {\n    return new Vector2(1, 0)\n  }\n\n  static unitY(): Vector2 {\n    return new Vector2(0, 1)\n  }\n}\n```",
          "dateTime": "2023-11-17T13:12:21.309Z"
        },
        {
          "indexTitle": "ImmutableVector2",
          "question": "ImmutableVector2",
          "answer": "```typescript\nimport { IVector2 } from 'engine_api'\n\ntype Operation = 'add' | 'subtract' | 'multiply' | 'divide'\n\nconst operationMap: Record<Operation, (a: number, b: number) => number> = {\n  add: (a, b) => a + b,\n  subtract: (a, b) => a - b,\n  multiply: (a, b) => a * b,\n  divide: (a, b) => (b !== 0 ? a / b : a),\n}\n\nexport default class ImmutableVector2 implements IVector2 {\n  constructor(public readonly x: number = 0, public readonly y: number = 0) {}\n\n  private operateWithImmutableVector(\n    { x = 0, y = 0 }: IVector2 | { x: number; y: number } = { x: 0, y: 0 },\n    operation: Operation = 'add'\n  ): ImmutableVector2 {\n    return new ImmutableVector2(\n      operationMap[operation](this.x, x),\n      operationMap[operation](this.y, y)\n    )\n  }\n\n  operate(\n    { x = 0, y = 0 }: IVector2 | { x?: number; y?: number } = {},\n    operation: Operation = 'add'\n  ): ImmutableVector2 {\n    return this.operateWithImmutableVector({ x, y }, operation)\n  }\n\n  add(other: IVector2): ImmutableVector2 {\n    return this.operateWithImmutableVector(other, 'add')\n  }\n\n  subtract(other: IVector2): ImmutableVector2 {\n    return this.operateWithImmutableVector(other, 'subtract')\n  }\n\n  multiply(scalar: number): ImmutableVector2 {\n    return this.operateWithImmutableVector({ x: scalar, y: scalar }, 'multiply')\n  }\n\n  dot(other: IVector2): number {\n    return this.x * other.x + this.y * other.y\n  }\n\n  length(): number {\n    return Math.hypot(this.x, this.y)\n  }\n\n  squaredLength(): number {\n    return this.x * this.x + this.y * this.y\n  }\n\n  normalize(): ImmutableVector2 {\n    const mag = this.length()\n    return mag !== 0\n      ? this.operateWithImmutableVector({ x: mag, y: mag }, 'divide')\n      : new ImmutableVector2()\n  }\n\n  static zero(): ImmutableVector2 {\n    return new ImmutableVector2()\n  }\n\n  static unitX(): ImmutableVector2 {\n    return new ImmutableVector2(1, 0)\n  }\n\n  static unitY(): ImmutableVector2 {\n    return new ImmutableVector2(0, 1)\n  }\n}\n```",
          "dateTime": "2023-11-17T13:14:02.838Z"
        },
        {
          "indexTitle": "Tests",
          "question": "Tests",
          "answer": "```bash\nVector2.test.ts\n```\n```typescript\nimport { Vector2, ImmutableVector2 } from 'engine'\n\nconst runVectorTests = (Vector: new (x: number, y: number) => any) => {\n  test('should add two vectors', () => {\n    const v1 = new Vector(1, 2)\n    const v2 = new Vector(3, 4)\n    const result = v1.add(v2)\n    expect(result).toEqual(new Vector(4, 6))\n  })\n\n  test('should subtract two vectors', () => {\n    const v1 = new Vector(5, 6)\n    const v2 = new Vector(2, 3)\n    const result = v1.subtract(v2)\n    expect(result).toEqual(new Vector(3, 3))\n  })\n\n  test('should multiply vector by scalar', () => {\n    const v = new Vector(2, 3)\n    const scalar = 2\n    const result = v.multiply(scalar)\n    expect(result).toEqual(new Vector(4, 6))\n  })\n\n  it('should calculate dot product of two vectors', () => {\n    const v1 = new Vector(2, 3)\n    const v2 = new Vector(4, 5)\n    const result = v1.dot(v2)\n\n    expect(result).toEqual(2 * 4 + 3 * 5)\n  })\n\n  it('should calculate the length of the vector', () => {\n    const v = new Vector(3, 4)\n    const result = v.length()\n\n    expect(result).toEqual(5)\n  })\n\n  it('should calculate the squared length of the vector', () => {\n    const v = new Vector(3, 4)\n    const result = v.squaredLength()\n\n    expect(result).toEqual(3 * 3 + 4 * 4)\n  })\n\n  it('should normalize the vector', () => {\n    const v = new Vector(3, 4)\n    const length = v.length()\n    const result = v.normalize()\n\n    const tolerance = 1e-8\n\n    const expected = length\n      ? new Vector(3 / length, 4 / length)\n      : new Vector(0, 0)\n\n    expect(result.x).toBeCloseTo(expected.x, tolerance)\n    expect(result.y).toBeCloseTo(expected.y, tolerance)\n  })\n\n  it('should handle zero vector normalization', () => {\n    const zeroVector = new Vector(0, 0)\n    const result = zeroVector.normalize()\n\n    expect(result).toEqual(new Vector(0, 0))\n  })\n\n  test('should chain multiple operations', () => {\n    const result = new Vector(1, 2)\n      .add(new Vector(3, 4))\n      .multiply(2)\n      .subtract(new Vector(1, 1))\n    expect(result).toEqual(new Vector(7, 11))\n  })\n\n  test('should destructure the result of an operation', () => {\n    const { x, y } = new Vector(2, 4).multiply(1.5)\n    expect(x).toBeCloseTo(3)\n    expect(y).toBeCloseTo(6)\n  })\n\n  test('should chain and destructure in one statement', () => {\n    const { x, y } = new Vector(1, 2)\n      .add(new Vector(3, 4))\n      .multiply(2)\n      .subtract(new Vector(1, 1))\n    expect(x).toEqual(7)\n    expect(y).toEqual(11)\n  })\n}\n\ndescribe('Vector2', () => {\n  runVectorTests(Vector2)\n})\n\ndescribe('ImmutableVector2', () => {\n  runVectorTests(ImmutableVector2)\n})\n```",
          "dateTime": "2023-11-17T13:15:19.915Z"
        }
      ]
    },
    {
      "title": "Entity-Component System",
      "chats": [
        {
          "indexTitle": "Assumptions",
          "question": "Assumptions",
          "answer": "",
          "dateTime": "2023-11-16T16:30:51.953Z"
        },
        {
          "indexTitle": "API",
          "question": "API",
          "answer": "```typescript\nexport interface IComponent {\n  update(): void\n  render(): void\n}\n```\n```typescript\nimport { IComponent } from './IComponent'\n\nexport interface IEntity {\n  addComponent(component: IComponent): void\n  update(): void\n  render(): void\n}\n```",
          "dateTime": "2023-11-16T17:15:37.390Z"
        },
        {
          "indexTitle": "Entity-Component",
          "question": "Entity-Component ",
          "answer": "```typescript\nimport { IComponent } from 'engine_api'\n\nexport class Component implements IComponent {\n  update() {}\n\n  render() {}\n}\n```\n```typescript\nimport { IComponent, IEntity } from 'engine_api'\n\nexport class Entity implements IEntity {\n  private components: IComponent[] = []\n\n  addComponent(component: IComponent) {\n    this.components.push(component)\n  }\n\n  update() {\n    for (const component of this.components) {\n      component.update()\n    }\n  }\n\n  render() {\n    for (const component of this.components) {\n      component.render()\n    }\n  }\n}\n```",
          "dateTime": "2023-11-16T22:07:34.047Z"
        },
        {
          "indexTitle": "Tests",
          "question": "Tests",
          "answer": "```bash\nEntityComponent.test.ts\n```\n```typescript\nimport { Entity, Component } from 'engine'\n\ndescribe('Entity and Component tests', () => {\n  test('Entity can add a component', () => {\n    const entity = new Entity()\n    const component = new Component()\n\n    entity.addComponent(component)\n\n    expect(entity['components']).toContain(component)\n  })\n\n  test('Entity update calls update on all components', () => {\n    const entity = new Entity()\n    const component1 = new Component()\n    const component2 = new Component()\n\n    entity.addComponent(component1)\n    entity.addComponent(component2)\n\n    const updateSpy1 = jest.spyOn(component1, 'update')\n    const updateSpy2 = jest.spyOn(component2, 'update')\n\n    entity.update()\n\n    expect(updateSpy1).toHaveBeenCalled()\n    expect(updateSpy2).toHaveBeenCalled()\n  })\n\n  test('Entity render calls render on all components', () => {\n    const entity = new Entity()\n    const component1 = new Component()\n    const component2 = new Component()\n\n    entity.addComponent(component1)\n    entity.addComponent(component2)\n\n    const renderSpy1 = jest.spyOn(component1, 'render')\n    const renderSpy2 = jest.spyOn(component2, 'render')\n\n    entity.render()\n\n    expect(renderSpy1).toHaveBeenCalled()\n    expect(renderSpy2).toHaveBeenCalled()\n  })\n})\n```",
          "dateTime": "2023-11-17T13:40:02.793Z"
        }
      ]
    },
    {
      "title": "Component",
      "chats": [
        {
          "indexTitle": "Assumptions",
          "question": "Assumptions",
          "answer": "1. Not sure if this is correct, to make Entity from such small elements, but maybe each bite send counts",
          "dateTime": "2023-11-17T13:46:20.974Z"
        },
        {
          "indexTitle": "PositionComponent",
          "question": "PositionComponent",
          "answer": "```typescript\nimport { IComponent, IVector2 } from 'engine_api'\nimport Vector2 from '../math/Vector2'\n\nexport default class PositionComponent implements IComponent {\n  public position: IVector2\n\n  constructor(initialPosition: IVector2 = Vector2.zero()) {\n    this.position = initialPosition\n  }\n\n  update() {}\n\n  render() {}\n}\n```",
          "dateTime": "2023-11-17T13:24:25.157Z"
        },
        {
          "indexTitle": "Tests",
          "question": "Tests",
          "answer": "```bash\nPositionComponent.test.ts\n```\n```typescript\nimport { PositionComponent, Vector2 } from 'engine'\n\ndescribe('PositionComponent tests', () => {\n  test('PositionComponent initializes with the correct position', () => {\n    const initialPosition = new Vector2(10, 20)\n    const positionComponent = new PositionComponent(initialPosition)\n\n    expect(positionComponent.position).toEqual(initialPosition)\n  })\n\n  test('PositionComponent can set and get the position', () => {\n    const positionComponent = new PositionComponent()\n    const newPosition = new Vector2(30, 40)\n\n    positionComponent.position = newPosition\n\n    expect(positionComponent.position).toEqual(newPosition)\n  })\n})\n```",
          "dateTime": "2023-11-17T13:42:56.582Z"
        }
      ]
    },
    {
      "title": "Renderer",
      "chats": [
        {
          "indexTitle": "Assumptions",
          "question": "Assumptions",
          "answer": "1. Basic Canvas renderer written manually\n2. Version with basic types and with my Vector2\n3. Probably to be replaceable by pixi or 3d libs on npm",
          "dateTime": "2023-11-17T13:31:47.701Z"
        },
        {
          "indexTitle": "BaseRenderer",
          "question": "BaseRenderer",
          "answer": "```typescript\nexport default abstract class BaseRenderer {\n  protected canvas: HTMLCanvasElement\n  protected context: CanvasRenderingContext2D\n\n  constructor(canvasId: string) {\n    this.canvas = document.getElementById(canvasId) as HTMLCanvasElement\n    this.context = this.canvas.getContext('2d')!\n  }\n\n  clearCanvas(): void {\n    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)\n  }\n\n  getContext(): CanvasRenderingContext2D {\n    return this.context\n  }\n}\n```",
          "dateTime": "2023-11-17T13:27:28.546Z"
        },
        {
          "indexTitle": "Renderer",
          "question": "Renderer",
          "answer": "```typescript\nimport { IRenderer } from 'engine_api'\nimport BaseRenderer from './BaseRenderer'\n\nexport default class Renderer extends BaseRenderer implements IRenderer {\n  constructor(canvasId: string) {\n    super(canvasId)\n  }\n\n  drawRect(\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    color: string\n  ): void {\n    this.context.fillStyle = color\n    this.context.fillRect(x, y, width, height)\n  }\n  // Add more drawing methods as needed (circles, images, etc.)\n}\n```",
          "dateTime": "2023-11-17T13:33:39.477Z"
        },
        {
          "indexTitle": "Renderer.test.ts",
          "question": "Renderer.test.ts",
          "answer": "```typescript\nimport { Renderer } from 'engine'\n\ndescribe('Renderer', () => {\n  let renderer: Renderer\n\n  beforeEach(() => {\n    document.body.innerHTML = '<canvas id=\"myCanvas\"></canvas>'\n    renderer = new Renderer('myCanvas')\n  })\n\n  test('clearCanvas method should clear the canvas', () => {\n    const red = '#ff0000'\n    const black = '#000000'\n    renderer.drawRect(0, 0, 10, 10, red)\n\n    expect(renderer.getContext().fillStyle).toBe(red)\n\n    renderer.clearCanvas()\n\n    expect(renderer.getContext().fillStyle).toBe(black)\n  })\n\n  test('drawRect method should draw a rectangle on the canvas', () => {\n    const blue = '#0000ff'\n    renderer.drawRect(0, 0, 10, 10, blue)\n\n    expect(renderer.getContext().fillStyle).toBe(blue)\n  })\n})\n```",
          "dateTime": "2023-11-17T18:55:46.372Z"
        },
        {
          "indexTitle": "RendererV2",
          "question": "RendererV2",
          "answer": "```typescript\nimport { IRendererV2, IVector2 } from 'engine_api'\nimport BaseRenderer from './BaseRenderer'\n\nexport default class RendererV2 extends BaseRenderer implements IRendererV2 {\n  constructor(canvasId: string) {\n    super(canvasId)\n  }\n\n  drawRect(position: IVector2, size: IVector2, color: string): void {\n    this.context.fillStyle = color\n    this.context.fillRect(position.x, position.y, size.x, size.y)\n  }\n  // Add more drawing methods as needed (circles, images, etc.)\n}\n```",
          "dateTime": "2023-11-17T13:34:11.940Z"
        },
        {
          "indexTitle": "RendererV2.test.ts",
          "question": "RendererV2.test.ts",
          "answer": "```typescript\nimport { RendererV2, Vector2 } from 'engine'\n\ndescribe('RendererV2', () => {\n  let renderer: RendererV2\n\n  beforeEach(() => {\n    document.body.innerHTML = '<canvas id=\"myCanvas\"></canvas>'\n    renderer = new RendererV2('myCanvas')\n  })\n\n  test('drawRect method should draw a rectangle on the canvas', () => {\n    const blue = '#0000ff'\n    renderer.drawRect(new Vector2(0, 0), new Vector2(10, 10), blue)\n\n    expect(renderer.getContext().fillStyle).toBe(blue)\n  })\n})\n```",
          "dateTime": "2023-11-17T18:57:03.794Z"
        }
      ]
    },
    {
      "title": "Game Loop",
      "chats": [
        {
          "indexTitle": "Assumptions",
          "question": "Assumptions",
          "answer": "1. subscribe, unsubscribe to update and render\n2. start, stop, pause, resume",
          "dateTime": "2023-11-17T21:26:38.091Z"
        },
        {
          "indexTitle": "API",
          "question": "API",
          "answer": "```typescript\nexport default interface IUpdateCallback {\n  (deltaTime: number): void;\n}\n```\n```typescript\nexport default interface IRenderCallback {\n  (deltaTime: number): void;\n}\n```\n```typescript\nexport default interface IGameLoop {\n  startLoop(): void;\n  stopLoop(): void;\n  pauseLoop(): void;\n  resumeLoop(): void;\n  subscribeToUpdate(callback: UpdateCallback): void;\n  unsubscribeFromUpdate(callback: UpdateCallback): void;\n  subscribeToRender(callback: RenderCallback): void;\n  unsubscribeFromRender(callback: RenderCallback): void;\n}\n```",
          "dateTime": "2023-11-17T21:38:02.671Z"
        },
        {
          "indexTitle": "Game Loop",
          "question": "GameLoop",
          "answer": "```typescript\nexport default class GameLoop implements IGameLoop {\n  private animationFrameId: number | null = null;\n  private lastFrameTime: number = 0;\n  private updateCallbacks: IUpdateCallback[] = [];\n  private renderCallbacks: IRenderCallback[] = [];\n  private paused: boolean = false;\n\n  startLoop(): void {\n    this.paused = false;\n    this.loop();\n  }\n\n  stopLoop(): void {\n    if (this.animationFrameId !== null) {\n      cancelAnimationFrame(this.animationFrameId);\n    }\n  }\n\n  pauseLoop(): void {\n    this.paused = true;\n  }\n\n  resumeLoop(): void {\n    this.paused = false;\n    this.loop();\n  }\n\n  loop = (): void => {\n    if (this.paused) {\n      return;\n    }\n\n    const currentTime = performance.now();\n    if (!this.lastFrameTime) {\n      this.lastFrameTime = currentTime;\n    }\n\n    const deltaTime = (currentTime - this.lastFrameTime) / 1000; // Convert to seconds\n\n    // Call update callbacks\n    this.updateCallbacks.forEach((callback) => callback(deltaTime));\n\n    // Call render callbacks with deltaTime\n    this.renderCallbacks.forEach((callback) => callback(deltaTime));\n\n    this.lastFrameTime = currentTime;\n\n    this.animationFrameId = requestAnimationFrame(this.loop);\n  };\n\n  subscribeToUpdate(callback: IUpdateCallback): void {\n    this.updateCallbacks.push(callback);\n  }\n\n  unsubscribeFromUpdate(callback: IUpdateCallback): void {\n    this.updateCallbacks = this.updateCallbacks.filter((cb) => cb !== callback);\n  }\n\n  subscribeToRender(callback: IRenderCallback): void {\n    this.renderCallbacks.push(callback);\n  }\n\n  unsubscribeFromRender(callback: IRenderCallback): void {\n    this.renderCallbacks = this.renderCallbacks.filter((cb) => cb !== callback);\n  }\n}\n```\nNow you can use stopLoop to completely stop the loop, pauseLoop to pause it, and resumeLoop to resume it. The startLoop method initiates or restarts the loop.\n",
          "dateTime": "2023-11-17T21:34:01.322Z"
        },
        {
          "indexTitle": "Tests",
          "question": "Tests",
          "answer": "```typescript\n// gameLoop.test.ts\n\nimport { GameLoop } from 'engine'\n\ndescribe('GameLoop', () => {\n  let gameLoop: GameLoop\n  let mockUpdateCallback: jest.Mock\n  let mockRenderCallback: jest.Mock\n\n  beforeEach(() => {\n    gameLoop = new GameLoop()\n    mockUpdateCallback = jest.fn()\n    mockRenderCallback = jest.fn()\n  })\n\n  afterEach(() => {\n    jest.clearAllMocks()\n  })\n\n  test('subscribeToUpdate adds update callback', () => {\n    gameLoop.subscribeToUpdate(mockUpdateCallback)\n    expect(gameLoop['updateCallbacks']).toContain(mockUpdateCallback)\n  })\n\n  test('unsubscribeFromUpdate removes update callback', () => {\n    gameLoop.subscribeToUpdate(mockUpdateCallback)\n    gameLoop.unsubscribeFromUpdate(mockUpdateCallback)\n    expect(gameLoop['updateCallbacks']).not.toContain(mockUpdateCallback)\n  })\n\n  test('subscribeToRender adds render callback', () => {\n    gameLoop.subscribeToRender(mockRenderCallback)\n    expect(gameLoop['renderCallbacks']).toContain(mockRenderCallback)\n  })\n\n  test('unsubscribeFromRender removes render callback', () => {\n    gameLoop.subscribeToRender(mockRenderCallback)\n    gameLoop.unsubscribeFromRender(mockRenderCallback)\n    expect(gameLoop['renderCallbacks']).not.toContain(mockRenderCallback)\n  })\n\n  test('startLoop calls requestAnimationFrame', () => {\n    window.requestAnimationFrame = jest.fn()\n\n    gameLoop.startLoop()\n\n    expect(window.requestAnimationFrame).toHaveBeenCalled()\n  })\n\n  test('stopLoop cancels requestAnimationFrame', () => {\n    window.cancelAnimationFrame = jest.fn()\n\n    gameLoop.startLoop()\n    gameLoop.stopLoop()\n\n    expect(window.cancelAnimationFrame).toHaveBeenCalled()\n  })\n\n  test('pauseLoop stops loop execution', () => {\n    const mockLoop = jest.spyOn(gameLoop, 'loop')\n\n    gameLoop.startLoop()\n    gameLoop.pauseLoop()\n\n    expect(mockLoop).toHaveBeenCalledTimes(1)\n  })\n\n  test('resumeLoop continues loop execution', () => {\n    const mockLoop = jest.spyOn(gameLoop, 'loop')\n\n    gameLoop.startLoop()\n    gameLoop.pauseLoop()\n    gameLoop.resumeLoop()\n\n    expect(mockLoop).toHaveBeenCalledTimes(2)\n  })\n})\n```",
          "dateTime": "2023-11-17T22:04:36.549Z"
        },
        {
          "indexTitle": "Integration",
          "question": "Integration",
          "answer": "```typescript\nimport { GameLoop } from 'engine';\nimport { Entity, Component } from 'engine'\n\nconst gameLoop = new GameLoop();\nconst entity1 = new Entity();\nconst positionComponent1 = new PositionComponent();\n\nconst entity2 = new Entity();\nconst positionComponent2 = new PositionComponent();\n\nentity1.addComponent(positionComponent1);\nentity2.addComponent(positionComponent2);\n\n// Subscribe entities to the game loop\ngameLoop.subscribeToUpdate((deltaTime) => {\n  entity1.update();\n  entity2.update();\n});\n\ngameLoop.subscribeToRender(() => {\n  entity1.render();\n  entity2.render();\n});\n```",
          "dateTime": "2023-11-17T21:14:53.111Z"
        }
      ]
    },
    {
      "title": "Input Manager",
      "chats": [
        {
          "indexTitle": "Assumptions",
          "question": "Assumptions",
          "answer": "1. ",
          "dateTime": "2023-11-17T21:26:38.091Z"
        },
        {
          "indexTitle": "API",
          "question": "API",
          "answer": "```typescript\nexport default interface IInputCallback {\n  (inputData: any): void;\n}\n```\n```typescript\nexport default interface IInputManager {\n  subscribeInputEvent(eventType: string, callback: InputCallback): void;\n  handleKeyDown(key: string): void;\n  handleKeyUp(key: string): void;\n  isKeyDown(key: string): boolean;\n}\n```",
          "dateTime": "2023-11-17T22:47:40.040Z"
        },
        {
          "indexTitle": "Input Manager",
          "question": "InputManager",
          "answer": "```typescript\nexport default class InputManager implements IInputManager {\n  private inputCallbacks: { [key: string]: InputCallback[] } = {};\n  private keyStates: { [key: string]: boolean } = {};\n\n  subscribeInputEvent(eventType: string, callback: InputCallback): void {\n    if (!this.inputCallbacks[eventType]) {\n      this.inputCallbacks[eventType] = [];\n    }\n    this.inputCallbacks[eventType].push(callback);\n  }\n\n  handleKeyDown(key: string): void {\n    this.keyStates[key] = true;\n    this.handleInputEvent('KeyDown', key);\n  }\n\n  handleKeyUp(key: string): void {\n    this.keyStates[key] = false;\n    this.handleInputEvent('KeyUp', key);\n  }\n\n  isKeyDown(key: string): boolean {\n    return this.keyStates[key] || false;\n  }\n\n  private handleInputEvent(eventType: string, inputData: any): void {\n    const callbacks = this.inputCallbacks[eventType];\n    if (callbacks) {\n      callbacks.forEach((callback) => callback(inputData));\n    }\n  }\n}\n```",
          "dateTime": "2023-11-17T22:54:38.952Z"
        },
        {
          "indexTitle": "Tests",
          "question": "Tests",
          "answer": "```typescript\n// inputManager.test.ts\nimport { InputManager } from './inputManager';\n\ndescribe('InputManager', () => {\n  let inputManager: InputManager;\n\n  beforeEach(() => {\n    inputManager = new InputManager();\n  });\n\n  it('should subscribe and trigger key events', () => {\n    const keyDownCallback = jest.fn();\n    const keyUpCallback = jest.fn();\n\n    inputManager.subscribeInputEvent('KeyDown', keyDownCallback);\n    inputManager.subscribeInputEvent('KeyUp', keyUpCallback);\n\n    inputManager.handleKeyDown('Space');\n    inputManager.handleKeyUp('Space');\n\n    expect(keyDownCallback).toHaveBeenCalledWith('Space');\n    expect(keyUpCallback).toHaveBeenCalledWith('Space');\n  });\n\n  it('should track key state', () => {\n    expect(inputManager.isKeyDown('Space')).toBeFalsy();\n\n    inputManager.handleKeyDown('Space');\n    expect(inputManager.isKeyDown('Space')).toBeTruthy();\n\n    inputManager.handleKeyUp('Space');\n    expect(inputManager.isKeyDown('Space')).toBeFalsy();\n  });\n});\n```",
          "dateTime": "2023-11-17T22:50:08.565Z"
        },
        {
          "indexTitle": "Integration",
          "question": "Integration",
          "answer": "```typescript\n// player.ts\nclass Player {\n  private x: number;\n  private y: number;\n\n  constructor() {\n    this.x = 0;\n    this.y = 0;\n  }\n\n  moveLeft() {\n    this.x -= 1;\n  }\n\n  moveRight() {\n    this.x += 1;\n  }\n\n  moveUp() {\n    this.y -= 1;\n  }\n\n  moveDown() {\n    this.y += 1;\n  }\n\n  getPosition() {\n    return { x: this.x, y: this.y };\n  }\n}\n\n// game.ts\nconst inputManager = new InputManager();\nconst player = new Player();\n\n// Subscribe to arrow key events\ninputManager.subscribeInputEvent('KeyDown', (key) => {\n  switch (key) {\n    case 'ArrowLeft':\n      player.moveLeft();\n      break;\n    case 'ArrowRight':\n      player.moveRight();\n      break;\n    case 'ArrowUp':\n      player.moveUp();\n      break;\n    case 'ArrowDown':\n      player.moveDown();\n      break;\n    default:\n      // Handle other keys or ignore\n      break;\n  }\n});\n\n// Game loop example\nfunction gameLoop() {\n  // Update player position or perform other game logic based on player input\n  console.log('Player position:', player.getPosition());\n\n  // Other game logic...\n\n  requestAnimationFrame(gameLoop);\n}\n\n// Event listener for keydown\ndocument.addEventListener('keydown', (event) => {\n  inputManager.handleKeyDown(event.key);\n});\n\n// Start the game loop\ngameLoop();\n```",
          "dateTime": "2023-11-17T22:51:17.355Z"
        }
      ]
    },
    {
      "title": "Examples",
      "chats": [
        {
          "indexTitle": "Object.assign",
          "question": "Object.assign",
          "answer": "```typescript\nclass Point {\n  constructor(public x: number = 0, public y: number = 0) {\n    Object.assign(this, { x: this.validateX(x), y: this.validateY(y) });\n  }\n\n  private validateX(value: number): number {\n    // Some validation logic for the 'x' property\n    return Math.max(value, 0);\n  }\n\n  private validateY(value: number): number {\n    // Some validation logic for the 'y' property\n    return Math.max(value, 0);\n  }\n}\n\n// Usage\nconst point = new Point(-5, 10);\nconsole.log(point); // Output: Point { x: 0, y: 10 }\n```",
          "dateTime": "2023-11-16T20:54:48.453Z"
        },
        {
          "indexTitle": "Basic Entity-Component System",
          "question": "Basic Entity-Component System",
          "answer": "```typescript\nclass Component {\n    update() {\n        // Implement component update logic\n    }\n\n    render() {\n        // Implement component render logic\n    }\n}\n\nclass Entity {\n    private components: Component[] = [];\n\n    addComponent(component: Component) {\n        this.components.push(component);\n    }\n\n    update() {\n        for (const component of this.components) {\n            component.update();\n        }\n    }\n\n    render() {\n        for (const component of this.components) {\n            component.render();\n        }\n    }\n}\n\n// Example usage:\nclass RenderComponent extends Component {\n    render() {\n        console.log(\"Rendering...\");\n    }\n}\n\nclass MovementComponent extends Component {\n    update() {\n        console.log(\"Updating position...\");\n    }\n}\n\nconst playerEntity = new Entity();\nplayerEntity.addComponent(new RenderComponent());\nplayerEntity.addComponent(new MovementComponent());\n\n// Update and render the entity\nplayerEntity.update();\nplayerEntity.render();\n```",
          "dateTime": "2023-11-16T17:15:07.916Z"
        },
        {
          "indexTitle": "Reasons for Immutable ",
          "question": "What is advantage of using immutable vector2 instead of muttable in ts ?",
          "answer": "Using an immutable Vector2 instead of a mutable one in TypeScript offers several advantages:\n\n1. **Predictable State:**\n   - Immutable objects cannot be changed once they are created. This helps avoid unexpected changes to the state of your Vector2 instance, leading to more predictable behavior in your code.\n\n2. **Concurrency:**\n   - Immutable data structures are inherently thread-safe. If you're working in a concurrent or parallel environment, using immutable Vector2 instances can help prevent race conditions and make it easier to reason about your code.\n\n3. **Debugging:**\n   - Immutable objects make it easier to debug code. Since their state doesn't change, you can trust that the values remain constant throughout their lifecycle, simplifying the debugging process.\n\n4. **Functional Programming:**\n   - Immutability aligns well with functional programming principles. It encourages the use of pure functions, which don't have side effects, leading to more maintainable and testable code.\n\n5. **Undo/Redo Functionality:**\n   - Immutable objects are well-suited for implementing undo/redo functionality. You can keep track of the state changes by storing previous versions of the Vector2 without worrying about them being modified elsewhere in your code.\n\nHere's a simple example in TypeScript using an immutable Vector2 class:\n\n```typescript\nclass Vector2 {\n  constructor(public readonly x: number, public readonly y: number) {}\n\n  add(other: Vector2): Vector2 {\n    return new Vector2(this.x + other.x, this.y + other.y);\n  }\n\n  // Other methods...\n\n  static zero(): Vector2 {\n    return new Vector2(0, 0);\n  }\n}\n\n// Example usage:\nconst vectorA = new Vector2(1, 2);\nconst vectorB = new Vector2(3, 4);\n\nconst sum = vectorA.add(vectorB);\nconsole.log(sum); // Output: Vector2 { x: 4, y: 6 }\n\nconst zeroVector = Vector2.zero();\nconsole.log(zeroVector); // Output: Vector2 { x: 0, y: 0 }\n```\n\nIn this example, the `Vector2` class is immutable, and methods like `add` return a new instance without modifying the existing ones.",
          "dateTime": "2023-11-16T22:12:59.941Z"
        }
      ]
    },
    {
      "title": "Highlight",
      "chats": [
        {
          "indexTitle": "PIXI.js",
          "question": "Pixi is a renderer only much more advanced right ?",
          "answer": "Yes, that's correct. PIXI.js is a powerful 2D rendering engine for the web that provides a wide range of features for creating rich and interactive graphics. It is more than just a renderer; it's a comprehensive library that includes rendering capabilities along with features like display objects, animation, interaction handling, and more.\n\nSome key features of PIXI.js include:\n\n1. **Display Objects:** PIXI allows you to work with a hierarchy of display objects, such as sprites, containers, text, and graphics.\n\n2. **WebGL and Canvas Rendering:** PIXI.js can utilize WebGL for hardware-accelerated rendering when available, providing better performance. It also has a fallback to the 2D canvas for compatibility with a wider range of devices.\n\n3. **Filters and Effects:** PIXI supports a variety of filters and effects that can be applied to display objects, allowing for advanced visual enhancements.\n\n4. **Interactivity:** PIXI provides built-in support for handling user interactions, making it easy to create interactive applications and games.\n\n5. **Asset Loader:** PIXI includes a flexible asset loader for handling the loading of images, spritesheets, and other resources.\n\n6. **Animation:** PIXI supports animations and tweening, making it easier to create dynamic and fluid movement in your applications.\n\n7. **Compatibility:** PIXI is designed to work across different platforms and devices, providing a consistent experience.\n\nIn summary, PIXI.js is a feature-rich 2D rendering engine that goes beyond a simple renderer, offering a robust set of tools and capabilities for building interactive and visually appealing web applications and games.",
          "dateTime": "2023-11-17T19:06:51.764Z"
        }
      ]
    },
    {
      "title": "Event System",
      "chats": [
        {
          "indexTitle": "Assumptions",
          "question": "Assumptions",
          "answer": "The provided code defines a simple event system in TypeScript. This event system allows different parts of a program, particularly in the context of a game engine or game development, to communicate with each other through events.\n\nLet's break down the code:\n\n1. **Event System Class:**\n   - `EventSystem` is a class that manages events and event handlers.\n   - It has a private property `events`, which is an object where keys are event names, and values are arrays of event handlers.\n\n2. **subscribe Method:**\n   - The `subscribe` method is used to add an event handler to a specific event.\n   - If the event doesn't exist in the `events` object, it creates an empty array for that event.\n   - It then adds the provided event handler to the array for the specified event.\n\n3. **publish Method:**\n   - The `publish` method is used to trigger an event and execute all the associated event handlers.\n   - It retrieves the array of event handlers for the specified event and calls each handler with optional data.\n\n4. **Example Usage:**\n   - An instance of `EventSystem` is created: `const eventSystem = new EventSystem();`\n   - An event ('PlayerMoved') is subscribed to, with a handler that logs the player's position when the event is triggered.\n   - The event is published with some data (player's new position).\n\n**In the context of a game engine or game development:**\n- **Subscribing to Events:** Different parts of the game engine or game can subscribe to events they are interested in. For example, the rendering system may subscribe to a 'PlayerMoved' event to update the player's visual representation.\n\n- **Publishing Events:** Various components of the game (e.g., player input, physics system) can publish events to notify other parts of the system about changes. For instance, when the player moves, a 'PlayerMoved' event is published with the new position.\n\n- **Loose Coupling:** The event system helps achieve loose coupling between different modules or systems. Components can communicate without needing direct references to each other, promoting modularity and maintainability.\n\n- **Flexibility:** It provides a flexible way to extend or modify the behavior of the system. New features can be added by introducing new events and corresponding handlers.\n\n- **Example Expansion:** In a game context, you might expand this by adding events for various game actions (e.g., 'EnemySpawned', 'GamePaused') and allowing different systems to react accordingly.",
          "dateTime": "2023-11-18T16:55:02.488Z"
        },
        {
          "indexTitle": "API",
          "question": "API",
          "answer": "```typescript\nexport default interface IEventHandler {\n  (data?: any): void;\n}\n```\n```typescript\nexport default interface IEventSystem {\n  subscribe(eventName: string, handler: EventHandler): void;\n  publish(eventName: string, data?: any): void;\n}\n```",
          "dateTime": "2023-11-18T17:01:02.310Z"
        },
        {
          "indexTitle": "Event System",
          "question": "EventSystem",
          "answer": "```typescript\nexport default class EventSystem implements EventSystemInterface {\n  private events: { [key: string]: EventHandler[] } = {};\n\n  subscribe(eventName: string, handler: EventHandler): void {\n    if (!this.events[eventName]) {\n      this.events[eventName] = [];\n    }\n    this.events[eventName].push(handler);\n  }\n\n  publish(eventName: string, data?: any): void {\n    const handlers = this.events[eventName];\n    if (handlers) {\n      handlers.forEach(handler => handler(data));\n    }\n  }\n}\n```",
          "dateTime": "2023-11-18T17:02:13.488Z"
        },
        {
          "indexTitle": "Tests",
          "question": "Tests",
          "answer": "```typescript\nimport { IEventSystem } from 'engine_api'\n\ndescribe('EventSystem', () => {\n  let eventSystem: IEventSystem;\n\n  beforeEach(() => {\n    eventSystem = new EventSystem();\n  });\n\n  it('should subscribe to and publish events', () => {\n    // Arrange\n    const eventName = 'TestEvent';\n    const eventData = { message: 'Hello, World!' };\n    let handlerCalled = false;\n\n    // Act\n    eventSystem.subscribe(eventName, (data) => {\n      handlerCalled = true;\n      expect(data).toEqual(eventData);\n    });\n\n    eventSystem.publish(eventName, eventData);\n\n    // Assert\n    expect(handlerCalled).toBe(true);\n  });\n\n  it('should handle multiple handlers for the same event', () => {\n    // Arrange\n    const eventName = 'MultiHandlerEvent';\n    const eventData = { value: 42 };\n    let handler1Called = false;\n    let handler2Called = false;\n\n    // Act\n    eventSystem.subscribe(eventName, (data) => {\n      handler1Called = true;\n      expect(data).toEqual(eventData);\n    });\n\n    eventSystem.subscribe(eventName, (data) => {\n      handler2Called = true;\n      expect(data).toEqual(eventData);\n    });\n\n    eventSystem.publish(eventName, eventData);\n\n    // Assert\n    expect(handler1Called).toBe(true);\n    expect(handler2Called).toBe(true);\n  });\n\n  it('should handle events without subscribers', () => {\n    // Arrange\n    const eventName = 'NoSubscriberEvent';\n    const eventData = { value: 123 };\n\n    // Act & Assert (no error should be thrown)\n    expect(() => eventSystem.publish(eventName, eventData)).not.toThrow();\n  });\n});\n\n```",
          "dateTime": "2023-11-18T17:04:17.111Z"
        },
        {
          "indexTitle": "Usage Example",
          "question": "Usage Example",
          "answer": "```typescript\n// Assuming the EventSystem and interfaces are in separate files\n\n// Import necessary interfaces and classes\nimport { EventSystemInterface, EventHandler } from './EventSystem';\n\n// PlayerInput component\nclass PlayerInput {\n  constructor(private eventSystem: EventSystemInterface) {}\n\n  // Simulate player movement and publish 'PlayerMoved' event\n  movePlayer(newPosition: { x: number; y: number }): void {\n    this.eventSystem.publish('PlayerMoved', newPosition);\n  }\n}\n\n// RenderingSystem component\nclass RenderingSystem {\n  constructor(private eventSystem: EventSystemInterface) {\n    // Subscribe to the 'PlayerMoved' event\n    this.eventSystem.subscribe('PlayerMoved', this.handlePlayerMoved);\n  }\n\n  // Event handler for 'PlayerMoved' event\n  private handlePlayerMoved = (position: { x: number; y: number }) => {\n    // Update the visual representation of the player\n    console.log(`RenderingSystem: Player moved to ${position.x}, ${position.y}`);\n    // Actual rendering logic would go here\n  };\n}\n\n// Example usage:\n\n// Create an instance of EventSystem\nconst eventSystem: EventSystemInterface = new EventSystem();\n\n// Create instances of PlayerInput and RenderingSystem with the EventSystem\nconst playerInput = new PlayerInput(eventSystem);\nconst renderingSystem = new RenderingSystem(eventSystem);\n\n// Simulate player movement\nplayerInput.movePlayer({ x: 15, y: 30 });\n```",
          "dateTime": "2023-11-18T17:06:02.133Z"
        }
      ]
    },
    {
      "title": "State Manager",
      "chats": [
        {
          "indexTitle": "Assumptions",
          "question": "Assumptions",
          "answer": "1.",
          "dateTime": "2023-11-18T17:17:40.559Z"
        },
        {
          "indexTitle": "API",
          "question": "API",
          "answer": "```typescript\nexport default interface IGenericState {\n  [key: string]: any;\n}\n```\n```typescript\nexport default interface IStateManager<T extends IGenericState> {\n  getState(): T;\n  updateState(newState: Partial<T>): void;\n}\n```\n",
          "dateTime": "2023-11-18T17:20:27.397Z"
        },
        {
          "indexTitle": "StateManager",
          "question": "StateManager",
          "answer": "```typescript\nexport default class StateManager<T extends IGenericState> implements IStateManager<T> {\n  private currentState: T;\n\n  constructor(initialState: T) {\n    this.currentState = { ...initialState };\n  }\n\n  getState(): T {\n    return { ...this.currentState };\n  }\n\n  updateState(newState: Partial<T>): void {\n    this.currentState = { ...this.currentState, ...newState };\n  }\n}\n```",
          "dateTime": "2023-11-18T17:21:08.303Z"
        },
        {
          "indexTitle": "Tests",
          "question": "Tests",
          "answer": "```typescript\n// stateManager.test.ts\n\nimport StateManager, { IPlayerState, ICustomState } from './stateManager';\n\n// Create a StateManager instance with IPlayerState for testing\nconst playerStateManager = new StateManager<IPlayerState>({\n  playerHealth: 100,\n  gameScore: 0,\n});\n\n// Create another StateManager with ICustomState for testing\nconst customStateManager = new StateManager<ICustomState>({\n  someValue: 'Hello',\n  anotherValue: 42,\n});\n\ndescribe('StateManager', () => {\n  describe('getState', () => {\n    it('should return the current state for PlayerState', () => {\n      const currentState = playerStateManager.getState();\n      expect(currentState).toEqual({\n        playerHealth: 100,\n        gameScore: 0,\n      });\n    });\n\n    it('should return the current state for CustomState', () => {\n      const currentState = customStateManager.getState();\n      expect(currentState).toEqual({\n        someValue: 'Hello',\n        anotherValue: 42,\n      });\n    });\n  });\n\n  describe('updateState', () => {\n    it('should update the state for PlayerState', () => {\n      playerStateManager.updateState({ gameScore: 50, playerHealth: 80 });\n      const currentState = playerStateManager.getState();\n      expect(currentState).toEqual({\n        playerHealth: 80,\n        gameScore: 50,\n      });\n    });\n\n    it('should update the state for CustomState', () => {\n      customStateManager.updateState({ someValue: 'World', anotherValue: 99 });\n      const currentState = customStateManager.getState();\n      expect(currentState).toEqual({\n        someValue: 'World',\n        anotherValue: 99,\n      });\n    });\n  });\n});\n```",
          "dateTime": "2023-11-18T17:26:20.306Z"
        },
        {
          "indexTitle": "Usage Example",
          "question": "Usage Example",
          "answer": "\n```typescript\nexport default interface IPlayerState {\n  playerHealth: number;\n  gameScore: number;\n}\n\nexport default interface ICustomState {\n  someValue: string;\n  anotherValue: number;\n}\n\n// Create a StateManager instance with IPlayerState\nconst playerStateManager = new StateManager<IPlayerState>({\n  playerHealth: 100,\n  gameScore: 0,\n});\n\n// Get the current state\nconst currentPlayerState = playerStateManager.getState();\nconsole.log(currentPlayerState);\n\n// Update the state\nplayerStateManager.updateState({ gameScore: 50, playerHealth: 80 });\nconsole.log(playerStateManager.getState());\n\n// Create another StateManager with ICustomState\nconst customStateManager = new StateManager<ICustomState>({\n  someValue: 'Hello',\n  anotherValue: 42,\n});\n\n// Get the current custom state\nconst currentCustomState = customStateManager.getState();\nconsole.log(currentCustomState);\n\n// Update the custom state\ncustomStateManager.updateState({ someValue: 'World', anotherValue: 99 });\nconsole.log(customStateManager.getState());\n```",
          "dateTime": "2023-11-18T18:03:46.179Z"
        }
      ]
    },
    {
      "title": "Resource Manager",
      "chats": [
        {
          "indexTitle": "Assumptions",
          "question": "Assumptions",
          "answer": "1. ",
          "dateTime": "2023-11-18T18:10:38.141Z"
        },
        {
          "indexTitle": "API",
          "question": "API",
          "answer": "```typescript\nexport default interface IResource {\n  key: string;\n  data: any;\n}\n```\n```typescript\nexport default interface IResourceManager {\n  loadResource(key: string, resource: any): Promise<void>;\n  unloadResource(key: string): void;\n  getResource(key: string): any | undefined;\n}\n```",
          "dateTime": "2023-11-18T18:12:27.043Z"
        },
        {
          "indexTitle": "ResourceManager",
          "question": "ResourceManager",
          "answer": "```typescript\nexport default class ResourceManager implements IResourceManager {\n  private loadedResources: { [key: string]: any } = {};\n\n  async loadResource(key: string, resource: any): Promise<void> {\n    return new Promise((resolve) => {\n      this.loadedResources[key] = resource;\n      resolve();\n    });\n  }\n\n  unloadResource(key: string): void {\n    if (this.loadedResources[key]) {\n      delete this.loadedResources[key];\n    }\n  }\n\n  getResource(key: string): any | undefined {\n    return this.loadedResources[key];\n  }\n}\n```",
          "dateTime": "2023-11-18T18:13:22.718Z"
        },
        {
          "indexTitle": "Tests",
          "question": "Tests",
          "answer": "```typescript\n// ResourceManager.test.ts\nimport { ResourceManager } from './ResourceManager';\n\ndescribe('ResourceManager', () => {\n  let resourceManager: ResourceManager;\n\n  beforeEach(() => {\n    resourceManager = new ResourceManager();\n  });\n\n  it('should load and unload resources', async () => {\n    const texture = new Image();\n    texture.src = 'path/to/texture.png';\n\n    // Load resource\n    await resourceManager.loadResource('playerTexture', texture);\n    expect(resourceManager.getResource('playerTexture')).toEqual(texture);\n\n    // Unload resource\n    resourceManager.unloadResource('playerTexture');\n    expect(resourceManager.getResource('playerTexture')).toBeUndefined();\n  });\n});\n```",
          "dateTime": "2023-11-18T18:15:34.818Z"
        },
        {
          "indexTitle": "Usage Example",
          "question": "Usage Example",
          "answer": "```typescript\nconst resourceManager: ResourceLoader = new ResourceManager();\n\n// Load a texture asynchronously\nconst loadTexture = (path: string): Promise<Resource> => {\n  return new Promise((resolve) => {\n    const texture = new Image();\n    texture.onload = () => resolve({ key: 'playerTexture', data: texture });\n    texture.src = path;\n  });\n};\n\n// Usage of asynchronous loading with async/await\nconst main = async () => {\n  const resource: Resource = await loadTexture('path/to/texture.png');\n  await resourceManager.loadResource(resource.key, resource.data);\n\n  // Get the loaded texture\n  const playerTexture = resourceManager.getResource(resource.key);\n  console.log(playerTexture);\n\n  // Unload the texture when it's no longer needed\n  resourceManager.unloadResource(resource.key);\n};\n\nmain();\n```",
          "dateTime": "2023-11-18T18:17:30.802Z"
        }
      ]
    },
    {
      "title": "Collision Detector ",
      "chats": [
        {
          "indexTitle": "Assumptions",
          "question": "Assumptions",
          "answer": "1. ",
          "dateTime": "2023-11-18T18:24:32.152Z"
        },
        {
          "indexTitle": "API",
          "question": "API",
          "answer": "```typescript\nexport default interface IGameObject {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n}\n\nexport default interface ICollisionInfo {\n  object1: IGameObject;\n  object2: IGameObject;\n}\n\nexport default interface ICollisionCallback {\n  (collisionInfo: ICollisionInfo): void;\n}\n\nexport default interface ICollisionDetector {\n  checkCollision(object1: GameObject, object2: GameObject): void;\n  subscribeToCollisions(callback: CollisionCallback): void;\n}\n```",
          "dateTime": "2023-11-18T18:28:37.416Z"
        },
        {
          "indexTitle": "Collision Detector",
          "question": "CollisionDetector",
          "answer": "```typescript\nexport default class CollisionDetector implements ICollisionDetector {\n  private collisionCallbacks: ICollisionCallback[] = [];\n\n  checkCollision(object1: IGameObject, object2: IGameObject): void {\n    const isColliding =\n      object1.x < object2.x + object2.width &&\n      object1.x + object1.width > object2.x &&\n      object1.y < object2.y + object2.height &&\n      object1.y + object1.height > object2.y;\n\n    if (isColliding) {\n      this.collisionCallbacks.forEach(callback => callback({ object1, object2 }));\n    }\n  }\n\n  subscribeToCollisions(callback: ICollisionCallback): void {\n    this.collisionCallbacks.push(callback);\n  }\n}\n```",
          "dateTime": "2023-11-18T18:30:20.965Z"
        },
        {
          "indexTitle": "Tests",
          "question": "Tests",
          "answer": "```typescript\n// collisionDetector.test.ts\nimport { CollisionDetector, GameObject, CollisionInfo, CollisionCallback } from './collisionDetector';\n\ndescribe('CollisionDetector', () => {\n  let collisionDetector: CollisionDetector;\n  let collisionCallback: jest.Mock;\n\n  beforeEach(() => {\n    collisionDetector = new CollisionDetector();\n    collisionCallback = jest.fn();\n    collisionDetector.subscribeToCollisions(collisionCallback);\n  });\n\n  test('should detect collision and invoke callback', () => {\n    const object1: GameObject = { x: 10, y: 10, width: 20, height: 20 };\n    const object2: GameObject = { x: 15, y: 15, width: 20, height: 20 };\n\n    collisionDetector.checkCollision(object1, object2);\n\n    const expectedCollisionInfo: CollisionInfo = { object1, object2 };\n    expect(collisionCallback).toHaveBeenCalledWith(expectedCollisionInfo);\n  });\n\n  test('should not detect collision when objects do not collide', () => {\n    const object1: GameObject = { x: 10, y: 10, width: 20, height: 20 };\n    const object2: GameObject = { x: 50, y: 50, width: 20, height: 20 };\n\n    collisionDetector.checkCollision(object1, object2);\n\n    expect(collisionCallback).not.toHaveBeenCalled();\n  });\n});\n```",
          "dateTime": "2023-11-18T18:31:08.746Z"
        },
        {
          "indexTitle": "Usage Example",
          "question": "Usage Example",
          "answer": "```typescript\nconst collisionDetector: ICollisionDetector = new CollisionDetector();\n\n// Subscribe to collision events\ncollisionDetector.subscribeToCollisions(collisionInfo => {\n  console.log('Collision detected!', collisionInfo);\n});\n\n// Simulate a collision\nconst object1: GameObject = { x: 10, y: 10, width: 20, height: 20 };\nconst object2: GameObject = { x: 15, y: 15, width: 20, height: 20 };\ncollisionDetector.checkCollision(object1, object2);\n```",
          "dateTime": "2023-11-18T18:33:03.253Z"
        }
      ]
    },
    {
      "title": "Sound Manager",
      "chats": [
        {
          "indexTitle": "Assumptions",
          "question": "Assumptions",
          "answer": "1. ",
          "dateTime": "2023-11-18T20:13:25.376Z"
        },
        {
          "indexTitle": "API",
          "question": "API",
          "answer": "```typescript\nexport default interface ISoundManager {\n  loadSound(url: string): Promise<AudioBuffer>;\n  playSound(buffer: AudioBuffer, loop?: boolean): AudioBufferSourceNode;\n  stopSound(source: AudioBufferSourceNode): void;\n}\n```",
          "dateTime": "2023-11-18T20:13:25.376Z"
        },
        {
          "indexTitle": "Sound Manager",
          "question": "SoundManager",
          "answer": "```typescript\nexport default class SoundManager implements ISoundManager {\n  private audioContext: AudioContext;\n\n  constructor() {\n    this.audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\n  }\n\n  loadSound(url: string): Promise<AudioBuffer> {\n    return fetch(url)\n      .then(response => response.arrayBuffer())\n      .then(data => this.audioContext.decodeAudioData(data));\n  }\n\n  playSound(buffer: AudioBuffer, loop: boolean = false): AudioBufferSourceNode {\n    const source = this.audioContext.createBufferSource();\n    source.buffer = buffer;\n    source.connect(this.audioContext.destination);\n    source.loop = loop;\n    source.start(0);\n\n    return source;\n  }\n\n  stopSound(source: AudioBufferSourceNode): void {\n    source.stop(0);\n  }\n}\n```",
          "dateTime": "2023-11-18T20:14:25.780Z"
        },
        {
          "indexTitle": "Tests",
          "question": "Tests",
          "answer": "```typescript\n//soundManager.test.ts\n\nimport { SoundManagerInterface } from './SoundManager'; // Assuming your SoundManager and interface are in the same directory\n\ndescribe('SoundManager', () => {\n  let soundManager: ISoundManager;\n\n  beforeEach(() => {\n    soundManager = new SoundManager();\n  });\n\n  test('loadSound should load a sound', async () => {\n    const url = 'path/to/sound.mp3';\n    const buffer = await soundManager.loadSound(url);\n    expect(buffer).toBeInstanceOf(AudioBuffer);\n  });\n\n  test('playSound should return an AudioBufferSourceNode', () => {\n    const dummyBuffer = {} as AudioBuffer; // You can use a mock or a real buffer for testing\n    const source = soundManager.playSound(dummyBuffer);\n    expect(source).toBeInstanceOf(AudioBufferSourceNode);\n  });\n\n  test('stopSound should stop the sound', () => {\n    const dummySource = {} as AudioBufferSourceNode; // You can use a mock or a real source for testing\n    const stopSpy = jest.spyOn(dummySource, 'stop');\n    \n    soundManager.stopSound(dummySource);\n\n    expect(stopSpy).toHaveBeenCalledWith(0);\n  });\n});\n```",
          "dateTime": "2023-11-18T20:16:55.274Z"
        },
        {
          "indexTitle": "Usage Example",
          "question": "Usage Example",
          "answer": "```typescript\nimport { SoundManagerInterface } from './SoundManager'; // Assuming your SoundManager and interface are in the same directory\n\ndescribe('SoundManager', () => {\n  let soundManager: ISoundManager;\n\n  beforeEach(() => {\n    soundManager = new SoundManager();\n  });\n\n  test('playSound and stopSound with async/await', async () => {\n    const url = 'path/to/sound.mp3';\n\n    try {\n      const buffer = await soundManager.loadSound(url);\n\n      // Play the loaded sound without looping\n      const source = soundManager.playSound(buffer);\n\n      // Stop the sound after 3 seconds (for example)\n      await new Promise(resolve => setTimeout(resolve, 3000));\n\n      // Stop the sound\n      soundManager.stopSound(source);\n    } catch (error) {\n      // Handle any errors during the process\n      console.error('Error:', error);\n    }\n  });\n});\n```",
          "dateTime": "2023-11-18T20:20:05.979Z"
        }
      ]
    },
    {
      "title": "Scene Manager",
      "chats": [
        {
          "indexTitle": "Assumptions",
          "question": "Assumptions",
          "answer": "1. ",
          "dateTime": "2023-11-18T20:34:17.446Z"
        },
        {
          "indexTitle": "API",
          "question": "API",
          "answer": "```typescript\nexport default interface IScene {\n  start(): void;\n}\n```\n```typescript\nexport default interface ISceneManager {\n  loadScene(scene: Scene): void;\n  unloadCurrentScene(): void;\n}\n```",
          "dateTime": "2023-11-18T20:36:16.038Z"
        },
        {
          "indexTitle": "SceneManager",
          "question": "SceneManager",
          "answer": "```typescript\nexport default class SceneManager implements ISceneManager {\n  private currentScene: Scene | null = null;\n\n  loadScene(scene: Scene): void {\n    this.unloadCurrentScene();\n    this.currentScene = scene;\n    this.currentScene.start();\n  }\n\n  unloadCurrentScene(): void {\n    if (this.currentScene) {\n      console.log('Unloading current scene');\n    }\n  }\n}\n```",
          "dateTime": "2023-11-18T20:37:09.362Z"
        },
        {
          "indexTitle": "Tests",
          "question": "Tests",
          "answer": "```typescript\n// sceneManager.test.ts\n\nimport { Scene, SceneManagerInterface, SceneManager } from './sceneManager';\n\nclass MockScene implements Scene {\n  start(): void {\n    console.log('Mock Scene Started');\n  }\n}\n\ndescribe('SceneManager', () => {\n  let sceneManager: SceneManagerInterface;\n\n  beforeEach(() => {\n    sceneManager = new SceneManager();\n  });\n\n  test('loads and unloads scenes correctly', () => {\n    const mockScene1 = new MockScene();\n    const mockScene2 = new MockScene();\n\n    // Load the first scene\n    sceneManager.loadScene(mockScene1);\n    expect(console.log).toHaveBeenCalledWith('Mock Scene Started');\n\n    // Unload the current scene\n    sceneManager.unloadCurrentScene();\n    expect(console.log).toHaveBeenCalledWith('Unloading current scene');\n\n    // Load the second scene\n    sceneManager.loadScene(mockScene2);\n    expect(console.log).toHaveBeenCalledWith('Mock Scene Started');\n  });\n});\n```",
          "dateTime": "2023-11-18T20:38:08.556Z"
        },
        {
          "indexTitle": "Usage Example",
          "question": "Usage Example",
          "answer": "```typescript\nconst sceneManager: ISceneManager = new SceneManager();\n\n// Define scenes\nclass StartScene implements Scene {\n  start(): void {\n    console.log('Starting Start Scene');\n  }\n}\n\nclass GameScene implements Scene {\n  start(): void {\n    console.log('Starting Game Scene');\n  }\n}\n\n// Load scenes\nsceneManager.loadScene(new StartScene());\n\n// Switch to another scene\nsceneManager.loadScene(new GameScene());\n```",
          "dateTime": "2023-11-18T20:39:06.257Z"
        }
      ]
    },
    {
      "title": "Animation Manager",
      "chats": [
        {
          "indexTitle": "Assumptions",
          "question": "Assumptions",
          "answer": "1. ",
          "dateTime": "2023-11-18T22:37:19.407Z"
        },
        {
          "indexTitle": "API",
          "question": "API",
          "answer": "```typescript\nexport default interface IAnimationCallback {\n  (progress: number): void;\n}\n```\n```typescript\nexport default interface IAnimationManager {\n  animate(duration: number, callback: IAnimationCallback): void;\n  addAnimation(animation: IAnimationCallback): void;\n}\n```",
          "dateTime": "2023-11-18T22:38:51.733Z"
        },
        {
          "indexTitle": "AnimationManager",
          "question": "AnimationManager",
          "answer": "```typescript\nexport default class AnimationManager implements IAnimationManager {\n  private animations: IAnimationCallback[] = [];\n\n  animate(duration: number, callback: IAnimationCallback): void {\n    const startTime = performance.now();\n\n    const animateFrame = () => {\n      const currentTime = performance.now();\n      const progress = (currentTime - startTime) / duration;\n\n      if (progress < 1) {\n        callback(progress);\n        requestAnimationFrame(animateFrame);\n      } else {\n        callback(1);\n      }\n    };\n\n    animateFrame();\n  }\n\n  addAnimation(animation: IAnimationCallback): void {\n    this.animations.push(animation);\n  }\n}\n```",
          "dateTime": "2023-11-18T22:39:58.515Z"
        },
        {
          "indexTitle": "Tests",
          "question": "Tests",
          "answer": "```typescript\n// animation.test.ts\nimport { AnimationManager, IAnimationCallback, IAnimationManager } from './animation';\n\n// Mocking the requestAnimationFrame function\njest.spyOn(window, 'requestAnimationFrame').mockImplementation((cb) => cb());\n\ndescribe('AnimationManager', () => {\n  let animationManager: IAnimationManager;\n  let scaleAnimation: IAnimationCallback;\n\n  beforeEach(() => {\n    animationManager = new AnimationManager();\n\n    scaleAnimation = jest.fn();\n  });\n\n  it('should add and play animation', () => {\n    animationManager.addAnimation(scaleAnimation);\n    animationManager.animate(2000, scaleAnimation);\n\n    // You can add assertions based on your specific use case\n    // For example, you can check if scaleAnimation was called with expected arguments.\n    expect(scaleAnimation).toHaveBeenCalledTimes(2); // Once when adding and once during animation\n  });\n});\n```",
          "dateTime": "2023-11-18T22:40:38.503Z"
        },
        {
          "indexTitle": "Usage Example",
          "question": "Usage Example",
          "answer": "```typescript\nconst animationManager = new AnimationManager();\n\nfunction scaleAnimation(progress: number) {\n  const scale = 1 + 0.5 * Math.sin(progress * Math.PI);\n  console.log(`Scaling animation: ${scale}`);\n}\n\nanimationManager.addAnimation(scaleAnimation);\nanimationManager.animate(2000, scaleAnimation);\n```",
          "dateTime": "2023-11-18T22:41:39.511Z"
        }
      ]
    }
  ]
}