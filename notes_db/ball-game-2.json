{
  "sections": [
    {
      "title": "plan",
      "chats": [
        {
          "question": "What is my plan with this ?",
          "answer": "**14.11.2023**\n1. Current state:\n  * 14.11.2023 game is not playable but maybe there is still potential in whole thing ?\n2. Plan\n  * button h toogles visability of collision regions, vectors and so on, it's not visible by default\n  * right button next to joystic should kick the ball\n  * note all code regions where data and params are, that have impact on gameplay mechanics",
          "dateTime": "2023-11-14T12:49:00.712Z"
        }
      ]
    },
    {
      "title": "Notes during coding",
      "chats": [
        {
          "question": "How to introduce animation to ball ?",
          "answer": "**04.11.2023**\n\n1. **Need to see how it was done in player**\n   - Player has class PlayerModel in client, it collects player data gathered from dtos send to client.\n   - Player has PlayerStateContext that handles states and rendering with animations\n\n2. **Things done for Ball**\n   - Ball also needs it's client model\n     * Model needs states BallState, BallStateType in shared-api lib, similar to players.\n   - Ball also needs it's StateContext class\n     * this class also needs IBallState similar to players\n       + changed IPlayerState to IState as it will be common with players and ball\n       + leaned against compiler to fix game and client packs with this rename\n     * this class also needs IdleState similar to players\n     * this class also needs BallRenderer similar to players\n   - Ball also needs animation data sililar to file playerData\n   - also Ball class needs to exist as a root of Ball class family inheritance just to handle it by name Ball\n\n3. **At this point client compiles again**\n   - Now there is a need to use added ball stuff in GameClient similar to how player is done\n   - Sprite is now showing in canvas :)\n\n4. **Script to handle config**\n    - I added script to turn of config that switches server to local (no longer shows i changes, till i turn it on again); it's committed as production value but locally it is now localhost and i wont accidentally commit it to repository since it is not in changes.\n\n**05.11.2023**\n\n5. **Switching animation for ball**\n    - In player switching state is done on server and send to client. Acctually player server has whole structure in model that also has states handling. It needs to be reproduced for ball.\n     * Acctually, first Player and Ball must be of same format, witch means: \n       + go to game api and refactor ball api to be similar to player one\n       + create BallModel class similar to PlayerModel, that has private fields and getters and setters\n       + that requires also to create state classes similar to players\n       + there is also need to add SocketEvents.BallState and BallStateDto in shared-api and dtos\n       + also BallBuilder needs to be refactor to be similar to players\n       + data also corrected\n       + added BallAction class, from here state change events will be probably send to client\n\n**06.11.2023**\n\n6. **Send ball state from server and recive in client**\n    - Sended ball state from server and recived on client, switching animations, logic for switching ball state on server based on velocity.\n    - Produced grass asset and drawn it on field",
          "dateTime": "2023-11-06T19:24:56.950Z"
        },
        {
          "question": "Ball dribling",
          "answer": "**10.11.2023**  \n* Project kind of runned out of steam  It is not fun to play at this point  Can it be fun ?   \n    \n  * Maybe introduce dribling,  \n     for player to have more control over ball ?  \n  \n  * I will test some concepts:  \n  \n    1. Just use elastity of the collision param to make ball sticky to player ?  \n       * Nope, 2.0 made ball very energetic after collision, while 0.0 made it immovable, 0.7 seems to be value for socket ball\n    2. Dribbler, based on collider :  \n```typescript\nimport { IBall, IPlayer } from 'game-api'\n\nexport class Dribbler {\n  private sumRadiiSquared: number = 0\n  private timers: { [playerId: string]: number } = {}\n\n  init(players: IPlayer[], ball: IBall) {\n    const rp = players[0].radius + 0.2 * players[0].radius\n    const rb = ball.radius + 0.2 * ball.radius\n    this.sumRadiiSquared = (rp + rb) ** 2\n  }\n\n  dribble(players: IPlayer[], ball: IBall, dt: number) {\n    for (const player of players) {\n      if (!player.ballCollision) {\n        this.dribbleAction(player, ball)\n      }\n      const distanceSquared = this.getDistanceSquared(ball, player)\n      const playerId = player.id\n      const playerTimer = this.timers[playerId] || 0\n\n      if (distanceSquared < this.sumRadiiSquared) {\n        if (this.isDribbleOn(players)) {\n          this.resetDribble(players)\n          console.log('dribble reset')\n        }\n        if (playerTimer >= 1000) {\n          player.ballCollision = false\n          console.log('dribble on')\n        } else {\n          this.timers[playerId] = playerTimer + dt\n        }\n      } else {\n        this.timers[playerId] = 0\n        player.ballCollision = true\n      }\n    }\n  }\n\n  private isDribbleOn(players: IPlayer[]) {\n    for (const player of players) {\n      if (player.ballCollision) return true\n    }\n    return false\n  }\n\n  private resetDribble(players: IPlayer[]) {\n    for (const player of players) {\n      player.ballCollision = true\n    }\n  }\n\n  private getDistanceSquared(ball: IBall, player: IPlayer) {\n    const x = ball.x - player.x\n    const y = ball.y - player.y\n    return x ** 2 + y ** 2\n  }\n\n  private dribbleAction(player: IPlayer, ball: IBall) {\n    ball.x = player.directionX\n    ball.y = player.directionY\n  }\n}\n```",
          "dateTime": "2023-11-10T23:10:56.328Z"
        },
        {
          "question": "12.11.2023\nJust imprve as much as possible in 4h",
          "answer": "1. Find a place where to put info that server is waking up.\n   * Text to wait for server and then on player is displaying\n\n2. I want to add ability to kick ball\n   * Added two buttons (next i need to add them to my input)",
          "dateTime": "2023-11-12T21:52:18.471Z"
        },
        {
          "question": "Button H toogles visability of collision regions, vectors and so on, it's not visible by default ?",
          "answer": "1. updated client api to hold key input\n2. implement H key in client.\n  * sharad-api SocketEvents needs keys event\n  * socketOutManager updated with event\n  * implemented H handler\n3. implement H on server\n   ",
          "dateTime": "2023-11-14T21:22:02.886Z"
        },
        {
          "question": "i have InputHandler for player input\n```typescript\nimport { IInput, ISocketOutManager } from 'client-api'\n\nexport class InputHandler {\n  private input: IInput = {\n    up: false,\n    down: false,\n    left: false,\n    right: false,\n  }\n\n  constructor(private readonly socketOutManager: ISocketOutManager) {\n    document.addEventListener('keydown', this.handleKeyDown.bind(this))\n    document.addEventListener('keyup', this.handleKeyUp.bind(this))\n  }\n\n  private handleKeyDown(event: KeyboardEvent) {\n    this.setKeyState(event.key, true)\n  }\n\n  private handleKeyUp(event: KeyboardEvent) {\n    this.setKeyState(event.key, false)\n  }\n\n  private setKeyState(key: string, state: boolean) {\n    switch (key) {\n      case 'ArrowUp':\n        this.input.up = state\n        break\n      case 'ArrowDown':\n        this.input.down = state\n        break\n      case 'ArrowLeft':\n        this.input.left = state\n        break\n      case 'ArrowRight':\n        this.input.right = state\n        break\n    }\n    this.socketOutManager.sendPlayerInput(this.input)\n  }\n\n  public getInput(): IInput {\n    return this.input\n  }\n}\n```\nnow i want similar one but for keys using\n```typescript\nexport interface IKeyInput {\n  H: boolean\n}\n```\npls write it",
          "answer": "Certainly! Here's a simple `KeyInputHandler` class for handling key inputs using the `IKeyInput` interface:\n\n```typescript\nimport { IKeyInput, ISocketOutManager } from 'client-api';\n\nexport class KeyInputHandler {\n  private keyInput: IKeyInput = {\n    H: false,\n  };\n\n  constructor(private readonly socketOutManager: ISocketOutManager) {\n    document.addEventListener('keydown', this.handleKeyDown.bind(this));\n    document.addEventListener('keyup', this.handleKeyUp.bind(this));\n  }\n\n  private handleKeyDown(event: KeyboardEvent) {\n    this.setKeyState(event.key, true);\n  }\n\n  private handleKeyUp(event: KeyboardEvent) {\n    this.setKeyState(event.key, false);\n  }\n\n  private setKeyState(key: string, state: boolean) {\n    switch (key) {\n      case 'h':\n      case 'H':\n        this.keyInput.H = state;\n        break;\n    }\n    this.socketOutManager.sendKeyInput(this.keyInput);\n  }\n\n  public getKeyInput(): IKeyInput {\n    return this.keyInput;\n  }\n}\n```\n\nThis `KeyInputHandler` class listens for 'keydown' and 'keyup' events and updates the `keyInput` object accordingly. It sends the updated input to the server using the `sendKeyInput` method from the `socketOutManager`.",
          "dateTime": "2023-11-14T21:05:40.727Z"
        }
      ]
    }
  ]
}