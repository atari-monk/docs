{
  "sections": [
    {
      "title": "Rules",
      "chats": [
        {
          "indexTitle": "Rules of this document",
          "question": "Rules of this document",
          "answer": "Put task 'Task X.' as a section.  \nTask coresponds to task in micro_engine_task_2024 document.  \nThen add to this section.  \nAdd classes that where coded in task.  \nJust their code with optional description.  \nPoint of this document is to visualize code changes during task.\n",
          "dateTime": "2024-01-03T10:35:28.189Z"
        }
      ]
    },
    {
      "title": "Task 30.",
      "chats": [
        {
          "indexTitle": "MovementComponent",
          "question": "MovementComponent",
          "answer": "```typescript\nimport { IEventSystem, IInputManager, IObject } from 'engine_api'\nimport Component from '../entity_component/Component'\nimport Vector2 from '../../math/vector/Vector2'\n\ntype KeyAction = () => void\n\nexport default class MovementComponent extends Component {\n  private readonly _keyActions: { [key: string]: KeyAction }\n  private readonly _cumulativeDirection: Vector2\n  private _pressedKeys: Set<string> = new Set()\n\n  constructor(\n    private readonly _object: IObject,\n    private readonly _eventSystem: IEventSystem,\n    private readonly _input: IInputManager,\n    private readonly _useArrowKeys: boolean = true\n  ) {\n    super('MovementComponent')\n\n    this._cumulativeDirection = new Vector2()\n    this._keyActions = this.initializeKeyActions()\n\n    this._input.subscribeInputEvent('KeyDown', (key) => {\n      this._pressedKeys.add(key)\n      this.handleKeys()\n    })\n\n    this._input.subscribeInputEvent('KeyUp', (key) => {\n      this._pressedKeys.delete(key)\n      this.handleKeys()\n    })\n  }\n\n  private initializeKeyActions(): { [key: string]: KeyAction } {\n    const keyActions: { [key: string]: KeyAction } = {}\n\n    if (this._useArrowKeys) {\n      keyActions['ArrowLeft'] = () => this.updateDirection(-1, 0)\n      keyActions['ArrowRight'] = () => this.updateDirection(1, 0)\n      keyActions['ArrowUp'] = () => this.updateDirection(0, -1)\n      keyActions['ArrowDown'] = () => this.updateDirection(0, 1)\n    } else {\n      keyActions['a'] = () => this.updateDirection(-1, 0)\n      keyActions['d'] = () => this.updateDirection(1, 0)\n      keyActions['w'] = () => this.updateDirection(0, -1)\n      keyActions['s'] = () => this.updateDirection(0, 1)\n    }\n\n    return keyActions\n  }\n\n  private updateDirection(x: number, y: number): void {\n    this._cumulativeDirection.x += x\n    this._cumulativeDirection.y += y\n  }\n\n  private handleKeys(): void {\n    //console.log('Before handling keys:', this._cumulativeDirection)\n\n    this._cumulativeDirection.x = 0\n    this._cumulativeDirection.y = 0\n\n    this._pressedKeys.forEach((key) => {\n      const action = this._keyActions[key]\n      if (action) {\n        action()\n      }\n    })\n\n    const direction = this._cumulativeDirection.clone().normalize()\n\n    const scaledDirection = new Vector2(\n      direction.x * this._object.moveStep.x,\n      direction.y * this._object.moveStep.y\n    )\n\n    this._object.velocity.setValues(scaledDirection)\n    this._eventSystem.publish('playerMove', this._object.id)\n  }\n}\n```",
          "dateTime": "2024-01-02T19:23:11.814Z"
        },
        {
          "indexTitle": "MovementComponent Refactor",
          "question": "MovementComponent Refactor",
          "answer": "Not used for now (ObjectComponent has all data for now), but much simpler :)\n```typescript\nimport { IVector2 } from 'engine_api'\nimport Component from '../entity_component/Component'\nimport Vector2 from '../../math/vector/Vector2'\n\nexport default class MovementComponent extends Component {\n  public velocity: IVector2 = Vector2.zero\n  public useArrowKeys: boolean = true\n  public moveSpeed: number = 50\n\n  constructor() {\n    super('MovementComponent')\n  }\n}\n```",
          "dateTime": "2024-01-03T10:43:33.940Z"
        },
        {
          "indexTitle": "MovementSubSystem",
          "question": "MovementSubSystem",
          "answer": "```typescript\nimport { IEventSystem, IInputManager } from 'engine_api'\nimport Vector2 from '../../../math/vector/Vector2'\nimport MovementComponent from '../../component/MovementComponent'\nimport ObjectComponent from '../../component/ObjectComponent'\n\ntype KeyAction = () => void\n\nexport default class MovementSubSystem {\n  private readonly _keyAction: { [key: string]: KeyAction }\n  private readonly _cumulativeDirection: Vector2 = new Vector2()\n  private _pressedKey: Set<string> = new Set()\n\n  constructor(\n    private readonly _input: IInputManager,\n    private readonly _eventSystem: IEventSystem,\n    private readonly _id: string,\n    useArrowKeys: boolean = true\n  ) {\n    this._keyAction = useArrowKeys\n      ? this.initArrowKeyAction()\n      : this.initWSADKeyAction()\n  }\n\n  private initArrowKeyAction(): { [key: string]: KeyAction } {\n    const keyActions: { [key: string]: KeyAction } = {}\n\n    keyActions['ArrowLeft'] = () => this.updateDirection(-1, 0)\n    keyActions['ArrowRight'] = () => this.updateDirection(1, 0)\n    keyActions['ArrowUp'] = () => this.updateDirection(0, -1)\n    keyActions['ArrowDown'] = () => this.updateDirection(0, 1)\n\n    return keyActions\n  }\n\n  private initWSADKeyAction(): { [key: string]: KeyAction } {\n    const keyActions: { [key: string]: KeyAction } = {}\n\n    keyActions['a'] = () => this.updateDirection(-1, 0)\n    keyActions['d'] = () => this.updateDirection(1, 0)\n    keyActions['w'] = () => this.updateDirection(0, -1)\n    keyActions['s'] = () => this.updateDirection(0, 1)\n\n    return keyActions\n  }\n\n  private updateDirection(x: number, y: number): void {\n    this._cumulativeDirection.x += x\n    this._cumulativeDirection.y += y\n  }\n\n  subscribeInput(objectComponent: ObjectComponent) {\n    this._input.subscribeInputEvent('KeyDown', (key) => {\n      if (!this._keyAction.hasOwnProperty(key)) return\n      this._pressedKey.add(key)\n      this.handleKeys(objectComponent)\n    })\n\n    this._input.subscribeInputEvent('KeyUp', (key) => {\n      if (!this._keyAction.hasOwnProperty(key)) return\n      this._pressedKey.delete(key)\n      this.handleKeys(objectComponent)\n    })\n  }\n\n  private handleKeys(objectComponent: ObjectComponent): void {\n    this._cumulativeDirection.x = 0\n    this._cumulativeDirection.y = 0\n\n    this._pressedKey.forEach((key) => {\n      const action = this._keyAction[key]\n      if (action) {\n        action()\n      }\n    })\n\n    const direction = this._cumulativeDirection.clone().normalize()\n\n    const scaledDirection = new Vector2(\n      direction.x * objectComponent.moveStep.x,\n      direction.y * objectComponent.moveStep.x\n    )\n\n    objectComponent.velocity.setValues(scaledDirection)\n    this._eventSystem.publish('playerMove', this._id)\n  }\n}\n```",
          "dateTime": "2024-01-02T19:30:29.093Z"
        },
        {
          "indexTitle": "MovementSystem",
          "question": "MovementSystem",
          "answer": "```typescript\nimport {\n  IEntity,\n  IEntityManager,\n  IEventSystem,\n  IInputManager,\n} from 'engine_api'\nimport MovementComponent from '../../component/MovementComponent'\nimport ObjectComponent from '../../component/ObjectComponent'\nimport MovementSubSystem from './MovementSubSystem'\nimport InitLogicSystemBase from './InitLogicSystemBase'\n\nexport default class MovementSystem extends InitLogicSystemBase {\n  private _subSystem: MovementSubSystem[] = []\n\n  constructor(\n    entityManager: IEntityManager,\n    private readonly _input: IInputManager,\n    private readonly _eventSystem: IEventSystem\n  ) {\n    super(entityManager)\n  }\n\n  initLogic(entity: IEntity) {\n    const movementComponent = entity.getComponentByType(MovementComponent)\n    const objectComponent = entity.getComponentByType(ObjectComponent)\n\n    const movementSubSystem = new MovementSubSystem(\n      this._input,\n      this._eventSystem,\n      objectComponent.id,\n      movementComponent.useArrowKeys\n    )\n    movementSubSystem.subscribeInput(objectComponent)\n    this._subSystem.push(movementSubSystem)\n  }\n}\n```",
          "dateTime": "2024-01-02T19:31:03.109Z"
        },
        {
          "indexTitle": "InitLogicSystemManager",
          "question": "InitLogicSystemManager",
          "answer": "This is added to engine and user can add systems that need to init on entities once.  \n```typescript\nimport MapManager from '../../entity_component/MapManager'\nimport IInitLogicSystem from './IInitLogicSystem'\nimport IInitLogicSystemManager from './IInitLogicSystemManager'\n\nexport default class InitLogicSystemManager\n  extends MapManager<IInitLogicSystem>\n  implements IInitLogicSystemManager\n{\n  init(): void {\n    for (const system of this.values()) {\n      system.init()\n    }\n  }\n}\n```",
          "dateTime": "2024-01-02T19:34:35.727Z"
        },
        {
          "indexTitle": "KinematicsComponent",
          "question": "KinematicsComponent",
          "answer": "Initially:  \n```typescript\nimport { IEntity, IEventSystem, IObject } from 'engine_api'\nimport Component from '../entity_component/Component'\nimport ObjectComponent from './ObjectComponent'\nimport Vector2 from '../../math/vector/Vector2'\n\nexport class KinematicsComponent extends Component {\n  private _objectComponent: IObject\n  private readonly frictionCoefficient: number = 0.85\n  private readonly stopThreshold: number = 3\n\n  constructor(\n    private readonly _entity: IEntity,\n    private readonly _eventSystem: IEventSystem\n  ) {\n    super('KinematicsComponent')\n    this._objectComponent = this._entity.getComponentByType(ObjectComponent)\n  }\n\n  update(dt: number) {\n    this._objectComponent.position.add(\n      Vector2.getNew(this._objectComponent.velocity).multiply(dt)\n    )\n\n    this._objectComponent.velocity.multiply(\n      Math.pow(this.frictionCoefficient, dt)\n    )\n\n    if (this._objectComponent.velocity.length() < this.stopThreshold) {\n      if (\n        this._objectComponent.velocity.x !== 0 ||\n        this._objectComponent.velocity.y !== 0\n      ) {\n        this._objectComponent.velocity.x = 0\n        this._objectComponent.velocity.y = 0\n        this._eventSystem.publish('ballStop')\n      }\n    }\n  }\n}\n```",
          "dateTime": "2024-01-02T20:15:08.921Z"
        },
        {
          "indexTitle": "KinematicsComponent Refactor",
          "question": "KinematicsComponent Refactor",
          "answer": "```typescript\nimport Component from '../entity_component/Component'\n\nexport class KinematicsComponent extends Component {\n  public frictionCoefficient: number = 0\n  public stopThreshold: number = 0\n\n  constructor() {\n    super('KinematicsComponent')\n  }\n}\n```",
          "dateTime": "2024-01-03T10:44:06.267Z"
        },
        {
          "indexTitle": "KinematicsSystem ",
          "question": "KinematicsSystem ",
          "answer": "```typescript\nimport { IEntity, IEntityManager, IEventSystem } from 'engine_api'\nimport LogicSystemBase from './LogicSystemBase'\nimport ObjectComponent from '../../component/ObjectComponent'\nimport Vector2 from '../../../math/vector/Vector2'\nimport { KinematicsComponent } from '../../component/KinematicsComponent'\n\nexport default class KinematicsSystem extends LogicSystemBase {\n  constructor(\n    entityManager: IEntityManager,\n    private readonly _eventSystem: IEventSystem\n  ) {\n    super(entityManager)\n  }\n\n  updateLogic(deltaTime: number, entity: IEntity): void {\n    const objectComponent = entity.getComponentByType(ObjectComponent)\n    const kinematicsComponent = entity.getComponentByType(KinematicsComponent)\n\n    objectComponent.position.add(\n      Vector2.getNew(objectComponent.velocity).multiply(deltaTime)\n    )\n\n    if (kinematicsComponent.frictionCoefficient > 0) {\n      objectComponent.velocity.multiply(\n        Math.pow(kinematicsComponent.frictionCoefficient, deltaTime)\n      )\n    }\n\n    if (\n      kinematicsComponent.stopThreshold > 0 &&\n      objectComponent.velocity.length() < kinematicsComponent.stopThreshold\n    ) {\n      if (\n        objectComponent.velocity.x !== 0 ||\n        objectComponent.velocity.y !== 0\n      ) {\n        objectComponent.velocity.x = 0\n        objectComponent.velocity.y = 0\n        this._eventSystem.publish('entityStopped', objectComponent.id)\n      }\n    }\n  }\n}\n```",
          "dateTime": "2024-01-02T21:36:16.110Z"
        }
      ]
    },
    {
      "title": "Task 32.",
      "chats": [
        {
          "indexTitle": "CollisionComponent Refactor",
          "question": "CollisionComponent Refactor  \n```typescript\nimport { ICollisionDetector, IEntity, IObject } from 'engine_api'\nimport Component from '../entity_component/Component'\nimport CollisionHandlerComponent from './CollisionHandlerComponent'\nimport ObjectComponent from './ObjectComponent'\n\nexport default class CollisionComponent extends Component {\n  private _object1: IObject\n  private _object2!: IObject\n\n  set object2(object: IObject) {\n    this._object2 = object\n  }\n\n  constructor(\n    private readonly _collisionDetector: ICollisionDetector,\n    private readonly _entity: IEntity\n  ) {\n    super('CollisionComponent')\n    this._object1 = this._entity.getComponentByType(ObjectComponent)\n  }\n\n  setCollisionHandler() {\n    const collisionHandlerComponent = this._entity.getComponentByType(\n      CollisionHandlerComponent\n    )\n    this._collisionDetector.subscribeToCollisions(\n      this._object1,\n      this._object2,\n      collisionHandlerComponent.handleCollision.bind(collisionHandlerComponent)\n    )\n  }\n\n  update(dt: number) {\n    this._collisionDetector.checkCollision(this._object1, this._object2)\n  }\n\n  render(dt: number) {}\n}\n```\nI want to have component with only data like in unity components, here i think only thing that is needed is to get id of entity and also provide setter for id of object to collide with, all logic will be deleted from here as it will be moved to system.",
          "answer": "Certainly! To simplify your `CollisionComponent` and make it more data-oriented, you can remove unnecessary logic and keep it focused on storing data. Here's a simplified version:\n\n```typescript\nimport { ICollisionDetector, IEntity, IObject } from 'engine_api';\nimport Component from '../entity_component/Component';\n\nexport default class CollisionComponent extends Component {\n  private _objectIdToCollideWith: string | null = null;\n\n  constructor(private readonly _entity: IEntity) {\n    super('CollisionComponent');\n  }\n\n  // Getter for the entity ID\n  get entityId(): string {\n    return this._entity.id;\n  }\n\n  // Setter for the object ID to collide with\n  set objectIdToCollideWith(objectId: string | null) {\n    this._objectIdToCollideWith = objectId;\n  }\n\n  // Getter for the object ID to collide with\n  get objectIdToCollideWith(): string | null {\n    return this._objectIdToCollideWith;\n  }\n}\n```\n\nIn this simplified version:\n\n- Removed `_collisionDetector` dependency: The collision detection logic will be handled by a system outside of this component.\n- Removed `_object1` and `_object2`: We store only the object ID to collide with, eliminating the need for specific object references.\n- Removed `setCollisionHandler` and `update` methods: These were handling collision logic, which you've mentioned will be moved to a system.\n\nNow, this `CollisionComponent` primarily serves as a data container, providing the entity ID and the object ID to collide with. The actual collision handling and logic will be implemented in a separate system using the data provided by this component.",
          "dateTime": "2024-01-03T11:52:48.326Z"
        },
        {
          "indexTitle": "CollisionComponent Proposal",
          "question": "CollisionComponent Proposal  \n```typescript\nimport Component from '../entity_component/Component'\n\nexport default class CollisionComponent extends Component {\n  private _objectIdToCollideWith!: string\n\n  constructor() {\n    super('CollisionComponent')\n  }\n\n  set objectIdToCollideWith(objectId: string) {\n    this._objectIdToCollideWith = objectId\n  }\n\n  get objectIdToCollideWith(): string {\n    return this._objectIdToCollideWith\n  }\n}\n```\nIn fact i think this will suffice",
          "answer": "Absolutely, your simplified version looks great for a data-oriented `CollisionComponent`. It stores the object ID to collide with and provides a setter and getter for that value. This minimalist approach aligns with the principle of keeping components as simple data containers, leaving the logic to systems. If this meets your requirements, it's a clean and straightforward implementation.",
          "dateTime": "2024-01-03T11:53:02.475Z"
        },
        {
          "indexTitle": "CollisionSystem Proposal",
          "question": "CollisionSystem Proposal",
          "answer": "```typescript\nimport {\n  ICollisionDetector,\n  ICollisionHandler,\n  IEntity,\n  IEntityManager,\n} from 'engine_api'\nimport LogicSystemBase from './logic/LogicSystemBase'\nimport ObjectComponent from '../../component/ObjectComponent'\nimport CollisionComponent from '../../component/CollisionComponent'\n\nexport default class CollisionSystem extends LogicSystemBase {\n  constructor(\n    entityManager: IEntityManager,\n    private readonly _collisionDetector: ICollisionDetector,\n    private readonly _collisionHandler: ICollisionHandler\n  ) {\n    super(entityManager)\n  }\n\n  initilize(entity: IEntity) {\n    const [objectComponent, objectComponent2] = this.getData(entity)\n    this._collisionDetector.subscribeToCollisions(\n      objectComponent,\n      objectComponent2,\n      this._collisionHandler.handleCollision.bind(this._collisionHandler)\n    )\n  }\n\n  private getData(entity: IEntity): [ObjectComponent, ObjectComponent] {\n    const objectComponent = entity.getComponentByType(ObjectComponent)\n    const collisionComponent = entity.getComponentByType(CollisionComponent)\n    const objectComponent2 = this.entityManager\n      .getStrict(collisionComponent.objectIdToCollideWith)\n      .getComponentByType(ObjectComponent)\n    return [objectComponent, objectComponent2]\n  }\n\n  updateLogic(deltaTime: number, entity: IEntity): void {\n    const [objectComponent, objectComponent2] = this.getData(entity)\n    this._collisionDetector.checkCollision(objectComponent, objectComponent2)\n  }\n}\n```",
          "dateTime": "2024-01-03T13:42:04.504Z"
        },
        {
          "indexTitle": "Use in game",
          "question": "Use in game  \nClumsy but at least its a system and not logic in component.  \nLogic in component should be defined in game, not engine, mostly.",
          "answer": "```typescript\nconst playerBallCollisionSystem = new CollisionSystem(\n      engine.entityManager,\n      engine.collisionManager.getCollisionDetector(),\n      new PlayerBallCollisionHandler(engine.eventSystem)\n    )\n    playerBallCollisionSystem.registerEntityByName('player1')\n    playerBallCollisionSystem.registerEntityByName('player2')\n    const player1Collider = player1.getComponentByType(CollisionComponent)\n    player1Collider.objectIdToCollideWith = ballObj.id\n    playerBallCollisionSystem.initilize(player1)\n    const player2Collider = player2.getComponentByType(CollisionComponent)\n    player2Collider.objectIdToCollideWith = ballObj.id\n    playerBallCollisionSystem.initilize(player2)\n    engine.logicSystemManager.add(\n      'playerBallCollision',\n      playerBallCollisionSystem\n    )\n\n    const ballGateCollisionSystem = new CollisionSystem(\n      engine.entityManager,\n      engine.collisionManager.getCollisionDetector(),\n      new BallGateCollisionHandler(\n        entityManager,\n        engine.entityDataManager,\n        engine.eventSystem\n      )\n    )\n    ballGateCollisionSystem.registerEntityByName('leftGate')\n    ballGateCollisionSystem.registerEntityByName('rightGate')\n    const leftGateCollider = leftGate.getComponentByType(CollisionComponent)\n    leftGateCollider.objectIdToCollideWith = ballObj.id\n    ballGateCollisionSystem.initilize(leftGate)\n    const rightGateCollider = rightGate.getComponentByType(CollisionComponent)\n    rightGateCollider.objectIdToCollideWith = ballObj.id\n    ballGateCollisionSystem.initilize(rightGate)\n    engine.logicSystemManager.add('ballGateCollision', ballGateCollisionSystem)\n```",
          "dateTime": "2024-01-03T13:46:23.943Z"
        }
      ]
    }
  ]
}